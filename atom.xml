<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>明天又是周六了</title>
  
  <subtitle>谦虚受益，满盈招损</subtitle>
  <link href="https://hansy.tech/atom.xml" rel="self"/>
  
  <link href="https://hansy.tech/"/>
  <updated>2021-01-30T14:59:34.000Z</updated>
  <id>https://hansy.tech/</id>
  
  <author>
    <name>Seven</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PyQt5-进度条</title>
    <link href="https://hansy.tech/2021/01/961660662.html"/>
    <id>https://hansy.tech/2021/01/961660662.html</id>
    <published>2021-01-30T14:59:34.000Z</published>
    <updated>2021-01-30T14:59:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>进度条类控件主要显示任务的执行进度。PyQt5主要提供两种类型进度条控件：进度条ProgressBar和滑块控件QSlider。</p><a id="more"></a><h2 id="一、ProgressBar：进度条"><a href="#一、ProgressBar：进度条" class="headerlink" title="一、ProgressBar：进度条"></a>一、ProgressBar：进度条</h2><p><img src= "/img/loading.gif" data-lazy-src="https://files.qter.org/portal/202011/07/063546ejiiije8zdab28g8.jpg"></p><p>Demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget</span><br><span class="line"><span class="keyword">from</span> PyQt5.uic <span class="keyword">import</span> loadUi</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QBasicTimer</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainForm</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        loadUi(<span class="string">&quot;Bar.ui&quot;</span>, self) </span><br><span class="line">        self.slot_init()    <span class="comment">#初始化槽函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slot_init</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 初始化变量</span></span><br><span class="line">        self.timer = QBasicTimer()</span><br><span class="line">        self.step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化函数</span></span><br><span class="line">        self.button.clicked.connect(self.onStart)</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onStart</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 判断进度条是否完成,完成则关闭窗体</span></span><br><span class="line">        <span class="keyword">if</span> self.button.text() == <span class="string">&#x27;完成&#x27;</span>:</span><br><span class="line">            self.close()</span><br><span class="line">        <span class="comment"># 判断计数器是否处于计数状态</span></span><br><span class="line">        <span class="keyword">if</span> self.timer.isActive(): </span><br><span class="line">            self.timer.stop()</span><br><span class="line">            self.button.setText(<span class="string">&#x27;开始&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.timer.start(<span class="number">100</span>, self)</span><br><span class="line">            self.button.setText(<span class="string">&#x27;停止&#x27;</span>)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="comment"># QBasicTimer的附属函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timerEvent</span>(<span class="params">self, e</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.step &gt;= <span class="number">100</span>:</span><br><span class="line">            self.timer.stop()</span><br><span class="line">            self.button.setText(<span class="string">&#x27;完成&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.step = self.step+<span class="number">1</span></span><br><span class="line">        self.progressBar.setValue(self.step)  <span class="comment"># 动态更新计数器的值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># from PyQt5 import QtGui</span></span><br><span class="line">        <span class="comment"># value = self.progressBar.value()</span></span><br><span class="line">        <span class="comment"># self.progressBar.setFont(QtGui.QFont(&quot;楷体&quot;, value))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app=QApplication(sys.argv)</span><br><span class="line">    w=MyMainForm()</span><br><span class="line">    w.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>其中的ui文件为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ui</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">class</span>&gt;</span>Form<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QWidget&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Form&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">x</span>&gt;</span>0<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">y</span>&gt;</span>0<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">width</span>&gt;</span>466<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">height</span>&gt;</span>353<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;windowTitle&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span>&gt;</span>Form<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QProgressBar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;progressBar&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">x</span>&gt;</span>100<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">y</span>&gt;</span>90<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">width</span>&gt;</span>301<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">height</span>&gt;</span>31<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">number</span>&gt;</span>0<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QPushButton&quot;</span> <span class="attr">name</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">x</span>&gt;</span>210<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">y</span>&gt;</span>150<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">width</span>&gt;</span>51<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">height</span>&gt;</span>31<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>开始<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">resources</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">connections</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ui</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/31/yAhabF.gif"></p><p>ProgressBar控件对应PyQt5中的QProgressBar类，常用方法及说明见下表，最常用的信号valueChanged，进度条值发生改变时发射。</p><p><img src= "/img/loading.gif" data-lazy-src="https://files.qter.org/portal/202011/07/063546z8mixdi885x7zhn8.jpg"></p><p><img src= "/img/loading.gif" data-lazy-src="https://files.qter.org/portal/202011/07/063547zgcztjj9cnqmmymq.jpg"></p><p>注：如果最小值和最大值都设置为0，进度条会显示为一个不断循环滚动的繁忙进度。</p><h2 id="二、QSlider：滑块控件"><a href="#二、QSlider：滑块控件" class="headerlink" title="二、QSlider：滑块控件"></a>二、QSlider：滑块控件</h2><p>PyQt5中提供两个滑动控件型输入控件QSlider和QScrollBar。</p><p><img src= "/img/loading.gif" data-lazy-src="https://files.qter.org/portal/202011/07/063547dseosfpy9r99r1rn.jpg"></p><p>Demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget</span><br><span class="line"><span class="keyword">from</span> PyQt5.uic <span class="keyword">import</span> loadUi</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainForm</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        loadUi(<span class="string">&quot;Slider.ui&quot;</span>, self)  </span><br><span class="line">        self.slot_init()   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slot_init</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.slider.valueChanged.connect(self.onStart)</span><br><span class="line"></span><br><span class="line">        self.slider.setMinimum(<span class="number">0</span>)       <span class="comment"># 设置最小值</span></span><br><span class="line">        self.slider.setMaximum(<span class="number">100</span>)     <span class="comment"># 设置最大值</span></span><br><span class="line">        self.slider.setValue(<span class="number">50</span>)        <span class="comment"># 设置当前值</span></span><br><span class="line">        <span class="comment"># # 刻度线</span></span><br><span class="line">        <span class="comment"># from PyQt5.QtWidgets import QSlider</span></span><br><span class="line">        <span class="comment"># self.slider.setTickPosition(QSlider.TicksBelow)</span></span><br><span class="line">        <span class="comment"># self.slider.setTickInterval(5)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onStart</span>(<span class="params">self</span>):</span></span><br><span class="line">        size=self.slider.value()</span><br><span class="line">        print(size)</span><br><span class="line">        self.label.setNum(size)</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app=QApplication(sys.argv)</span><br><span class="line">    w=MyMainForm()</span><br><span class="line">    w.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ui</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">class</span>&gt;</span>Form<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QWidget&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Form&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">x</span>&gt;</span>0<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">y</span>&gt;</span>0<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">width</span>&gt;</span>452<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">height</span>&gt;</span>326<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;windowTitle&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span>&gt;</span>Form<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QSlider&quot;</span> <span class="attr">name</span>=<span class="string">&quot;slider&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">x</span>&gt;</span>140<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">y</span>&gt;</span>150<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">width</span>&gt;</span>160<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">height</span>&gt;</span>22<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;orientation&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">enum</span>&gt;</span>Qt::Horizontal<span class="tag">&lt;/<span class="name">enum</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QLabel&quot;</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">x</span>&gt;</span>210<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">y</span>&gt;</span>120<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">width</span>&gt;</span>41<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">height</span>&gt;</span>21<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">resources</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">connections</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ui</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/31/yAhUDU.gif"></p><p>QSlider和QScrollBar类常用方法及说明</p><p><img src= "/img/loading.gif" data-lazy-src="https://files.qter.org/portal/202011/07/063548qbs2p1s1fjjugfl1.jpg"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;进度条类控件主要显示任务的执行进度。PyQt5主要提供两种类型进度条控件：进度条ProgressBar和滑块控件QSlider。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://hansy.tech/categories/Python/"/>
    
    <category term="PyQt5" scheme="https://hansy.tech/categories/Python/PyQt5/"/>
    
    
    <category term="Python可视化" scheme="https://hansy.tech/tags/Python%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5-读取本地视频播放与暂停</title>
    <link href="https://hansy.tech/2021/01/1998954586.html"/>
    <id>https://hansy.tech/2021/01/1998954586.html</id>
    <published>2021-01-20T08:03:17.000Z</published>
    <updated>2021-01-20T08:03:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>实现一个读取本地视频的窗口。要求用同一个按钮完成读取视频与结束视频的功能，另外用同一个按钮完成播放与暂停的功能。</p><a id="more"></a><p>这两个按钮代表的4个功能在逻辑上需要理清，我认为以下的三个问题需要考虑到。</p><h4 id="问题1：在视频播放途中（按钮2的值为关闭），先点击暂停（按钮2的值变为继续），再点击关闭，此时整个界面是什么现象？"><a href="#问题1：在视频播放途中（按钮2的值为关闭），先点击暂停（按钮2的值变为继续），再点击关闭，此时整个界面是什么现象？" class="headerlink" title="问题1：在视频播放途中（按钮2的值为关闭），先点击暂停（按钮2的值变为继续），再点击关闭，此时整个界面是什么现象？"></a>问题1：在视频播放途中（按钮2的值为关闭），先点击暂停（按钮2的值变为继续），再点击关闭，此时整个界面是什么现象？</h4><p>答：错误的现象是：暂停操作把timer_camera给stop，导致在点击按钮1时，程序误认为视频已经被关闭，需要重新导入文件，并且两个按钮的值都不会被更新，导致再次导入视频进行播放时，按钮2的值显示为“继续”。根本原因就是没有分清timer_camera是因为视频被关闭而stop，还是因为暂停动作而stop。这是很严重的逻辑错误。<br>        正确的现象是：暂停后关闭，首先界面会清空，其次两个按钮的值都会重置。即按钮1的值变为“选择上传”，按钮2的值变为“暂停”</p><p>解决办法：增加一个signal信号，初始为0，在暂停后赋值为1，在Video函数判断timer_camera是否isActive时顺便检查这个信号，只有timer_camera关闭并且signal=0时才能去读取本地文件，否则就将signal赋值为0，然后再对整个界面重置</p><h4 id="问题2：在未选择视频时点击暂停，暂停是否无效？按钮2的值会更新吗？"><a href="#问题2：在未选择视频时点击暂停，暂停是否无效？按钮2的值会更新吗？" class="headerlink" title="问题2：在未选择视频时点击暂停，暂停是否无效？按钮2的值会更新吗？"></a>问题2：在未选择视频时点击暂停，暂停是否无效？按钮2的值会更新吗？</h4><p>答：无效，不会更新，即点击后任何反应都没有。<br>解决方法：在刚进入Video_Pause函数时判断一下是否有视频在播放，有视频在播放时才进行后续操作</p><h4 id="问题3：播放完成后按钮1的值是什么？-窗口里显示什么？"><a href="#问题3：播放完成后按钮1的值是什么？-窗口里显示什么？" class="headerlink" title="问题3：播放完成后按钮1的值是什么？ 窗口里显示什么？"></a>问题3：播放完成后按钮1的值是什么？ 窗口里显示什么？</h4><p>答：按钮1的值显示“播放结束”，窗口里显示视频最后一帧。再次点击按钮1后，按钮1的值变为“选择上传”，窗口清空<br>解决方法：在刚进入Video_Play函数时判断是否结束，结束时把按钮1的值从“关闭”更新为“播放结束”，对界面不做处理，即停在最后一帧。另外，在Video函数的刚开始位置，设置窗口clear语句，清空窗口，这样就能保证当前按钮1不论是“选择上传”状态，还是“播放结束状态”，还是“关闭”状态，只要一点击，窗口内容就会清空，合情合理。</p><h5 id="关于视频画面的自适应问题"><a href="#关于视频画面的自适应问题" class="headerlink" title="关于视频画面的自适应问题"></a>关于视频画面的自适应问题</h5><ol><li>直接读取的话，显示多大区域的视频画面取决于你的label标签有多大。比如视频尺寸是800x600，而label大小是600x600，那么有一部分的画面被切割掉，无法显示</li><li>使用 self.view.setScaledContents(True) , 自适应。将视频进行形变，使之尺寸与label相同，可以达到画面完全显示的效果，但是会产生形变，扭曲</li><li>获取视频的尺寸，然后resize界面中label的大小，使二者尺寸相同。这样也可以实现画面完全展示的目的，但视频可能会过长或过宽，以至于超出界面的边界，这时候调整一下边界就好了，所以在这种方法下最好不要用 self.setFixedSize 。 另外，如果label的四周有别的控件，视频尺寸又过大时，可能会影响整体的布局</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget,QMessageBox,QFileDialog</span><br><span class="line"><span class="keyword">from</span> PyQt5.uic <span class="keyword">import</span> loadUi</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtCore,QtGui</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv2</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainForm</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        loadUi(<span class="string">&quot;Frame.ui&quot;</span>, self)  <span class="comment">#加载UI文件</span></span><br><span class="line">        <span class="comment"># self.setFixedSize(550,550)   # 固定大小不可放缩  </span></span><br><span class="line">        self.slot_init()    <span class="comment">#初始化槽函数</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;初始化所有槽函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slot_init</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 初始化变量</span></span><br><span class="line">        self.cap = cv2.VideoCapture()       <span class="comment">#视频流</span></span><br><span class="line">        self.timer_camera = QtCore.QTimer() <span class="comment">#定义定时器，用于控制显示视频的帧率</span></span><br><span class="line">        self.signal=<span class="number">0</span>    <span class="comment"># 用于解决问题1。区分timer_camera是因为视频被关闭而stop，还是因为暂停动作而stop。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化函数</span></span><br><span class="line">        self.upload.clicked.connect(self.Video)</span><br><span class="line">        self.timer_camera.timeout.connect(self.Video_Play)</span><br><span class="line">        self.pause.clicked.connect(self.Video_Pause)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Video</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.view.clear()  <span class="comment"># 用于解决问题3 。每次想选择新视频时，显示界面都清空一下</span></span><br><span class="line">        <span class="keyword">if</span> self.timer_camera.isActive() == <span class="literal">False</span> <span class="keyword">and</span> self.signal==<span class="number">0</span>:</span><br><span class="line">            selectFileName,_ = QFileDialog.getOpenFileName(self,<span class="string">&#x27;选择文件&#x27;</span>,<span class="string">&#x27;./&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> selectFileName == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                QMessageBox.information(self,<span class="string">&quot;提示&quot;</span>,<span class="string">&quot;请选择文件&quot;</span>,QMessageBox.Yes)</span><br><span class="line">            <span class="keyword">elif</span>(selectFileName.lower().endswith((<span class="string">&#x27;.mp4&#x27;</span>, <span class="string">&#x27;.avi&#x27;</span>,<span class="string">&#x27;flv&#x27;</span>))==<span class="literal">False</span>):</span><br><span class="line">                QMessageBox.warning(self,<span class="string">&#x27;警告&#x27;</span>,<span class="string">&#x27;请输入正确的视频格式&#x27;</span>,QMessageBox.Yes)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># # 使画面完全展示  ， 但是无法控制视频展示画面的尺寸</span></span><br><span class="line">                <span class="comment"># mp4 = cv2.VideoCapture(selectFileName)</span></span><br><span class="line">                <span class="comment"># width  = mp4.get(cv2.CAP_PROP_FRAME_WIDTH)   # float</span></span><br><span class="line">                <span class="comment"># height = mp4.get(cv2.CAP_PROP_FRAME_HEIGHT)  # float</span></span><br><span class="line">                <span class="comment"># self.view.resize(int(width),int(height))</span></span><br><span class="line">              </span><br><span class="line">                flag = self.cap.<span class="built_in">open</span>(selectFileName)</span><br><span class="line">                <span class="keyword">if</span> flag:   <span class="comment"># 检测视频是否被打开</span></span><br><span class="line">                    self.timer_camera.start(<span class="number">30</span>)    </span><br><span class="line">                    self.upload.setText(<span class="string">&#x27;关闭&#x27;</span>)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.signal=<span class="number">0</span></span><br><span class="line">            self.pause.setText(<span class="string">&#x27;暂停&#x27;</span>)</span><br><span class="line">            self.timer_camera.stop()</span><br><span class="line">            self.cap.release()</span><br><span class="line">            <span class="comment">#self.view.clear()  # 如果加上这一句，就会在播放完毕时自动清空显示界面</span></span><br><span class="line">            self.upload.setText(<span class="string">&#x27;选择上传&#x27;</span>)</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Video_Play</span>(<span class="params">self</span>):</span></span><br><span class="line">        flag,self.image = self.cap.read()  <span class="comment">#从视频流中读取.当flag为False时，表示视频位于最后一帧。</span></span><br><span class="line">        <span class="keyword">if</span> flag: <span class="comment"># 用于解决问题3 。  检测视频是否播放完毕</span></span><br><span class="line">            show = cv2.cvtColor(self.image,cv2.COLOR_BGR2RGB) <span class="comment">#视频色彩转换回RGB，这样才是现实的颜色</span></span><br><span class="line">            img = QtGui.QImage(show.data,show.shape[<span class="number">1</span>],show.shape[<span class="number">0</span>],QtGui.QImage.Format_RGB888) <span class="comment">#把读取到的视频数据变成QImage形式</span></span><br><span class="line">            self.view.setPixmap(QtGui.QPixmap.fromImage(img))  <span class="comment">#往显示视频的Label里 显示QImage</span></span><br><span class="line">            self.view.setScaledContents(<span class="literal">True</span>)   <span class="comment"># 使画面完全展示+比例自适应。    保证能够显示视频画面里得所有内容，但是会变形、扭曲</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.upload.setText(<span class="string">&#x27;播放完毕&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Video_Pause</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        flag,self.image = self.cap.read()</span><br><span class="line">        <span class="keyword">if</span> flag:   <span class="comment"># 用于解决问题2 。保证只有在视频被选中且播放时，这个按钮被按时才有效果</span></span><br><span class="line">            <span class="keyword">if</span> self.timer_camera.isActive() == <span class="literal">False</span>:</span><br><span class="line">                self.timer_camera.start(<span class="number">30</span>)</span><br><span class="line">                self.pause.setText(<span class="string">&#x27;暂停&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.signal=<span class="number">1</span>   </span><br><span class="line">                self.timer_camera.stop()</span><br><span class="line">                self.pause.setText(<span class="string">&#x27;继续&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app=QApplication(sys.argv)</span><br><span class="line">    w=MyMainForm()</span><br><span class="line">    w.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>相应的ui文件为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ui</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">class</span>&gt;</span>Form<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QWidget&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Form&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">x</span>&gt;</span>0<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">y</span>&gt;</span>0<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">width</span>&gt;</span>980<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">height</span>&gt;</span>832<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;windowTitle&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span>&gt;</span>Form<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QLabel&quot;</span> <span class="attr">name</span>=<span class="string">&quot;view&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">x</span>&gt;</span>50<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">y</span>&gt;</span>160<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">width</span>&gt;</span>881<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">height</span>&gt;</span>611<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QPushButton&quot;</span> <span class="attr">name</span>=<span class="string">&quot;upload&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">x</span>&gt;</span>200<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">y</span>&gt;</span>80<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">width</span>&gt;</span>93<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">height</span>&gt;</span>28<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>选择上传<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QPushButton&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pause&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">x</span>&gt;</span>660<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">y</span>&gt;</span>80<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">width</span>&gt;</span>93<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">height</span>&gt;</span>28<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>暂停<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">resources</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">connections</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ui</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果为</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/han-suyu/cdn_others/Demo2.gif" alt="Demo"></p><p>值得一提的是，OpenCV中使用VideoCapture类读的视频是没有音频的，OpenCV只是一个图像库。如果要进一步处理音频则需要用到一个库——MoviePy，这个库是Python视频编辑库，可裁剪、拼接、标题插入、视频合成、视频处理和自定义效果。如果想在显示画面的时候播放音频，可以用多线程的方法，两个任务同时开启。但是如果视频播放后续支持进度条拖动或者倍速，这种方案又不行了，想要更改音频播放的速度有点困难。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;实现一个读取本地视频的窗口。要求用同一个按钮完成读取视频与结束视频的功能，另外用同一个按钮完成播放与暂停的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://hansy.tech/categories/Python/"/>
    
    <category term="PyQt5" scheme="https://hansy.tech/categories/Python/PyQt5/"/>
    
    
    <category term="Python可视化" scheme="https://hansy.tech/tags/Python%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5-QtDesigner入门</title>
    <link href="https://hansy.tech/2021/01/1266616007.html"/>
    <id>https://hansy.tech/2021/01/1266616007.html</id>
    <published>2021-01-20T08:01:29.000Z</published>
    <updated>2021-01-20T08:01:29.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>程序的用户交互界面，英文称之为 UI (user interface)</p><p>当一个应用的 UI 比较复杂的时候，命令行方式就不便用户使用了，这时我们需要图形界面。</p><a id="more"></a><h2 id="python图形界面开发"><a href="#python图形界面开发" class="headerlink" title="python图形界面开发"></a>python图形界面开发</h2><p>如果用 <code>Python</code> 语言开发 <code>跨平台</code> 的图形界面的程序，主要有3种选择：</p><ul><li><p>Tkinter</p><p>基于Tk的Python库，这是Python官方采用的标准库，优点是作为Python标准库、稳定、发布程序较小，缺点是控件相对较少。</p></li><li><p>wxPython</p><p>基于wxWidgets的Python库，优点是控件比较丰富，缺点是稳定性相对差点、文档少、用户少。</p></li><li><p>PySide2、PyQt5</p><p>基于Qt 的Python库，优点是控件比较丰富、跨平台体验好、文档完善、用户多。</p><p>缺点是 库比较大，发布出来的程序比较大。</p></li></ul><p>如果我们要开发的工具较小，界面比较简单，那我们可以选择Tkinter，如果控件较多功能较复杂，我们可以采用采用基于Qt的PySide2、PyQt5。</p><h2 id="PySide2、PyQt5-简介"><a href="#PySide2、PyQt5-简介" class="headerlink" title="PySide2、PyQt5 简介"></a>PySide2、PyQt5 简介</h2><p>PySide2、PyQt5 都是基于著名的 Qt 库。</p><p>Qt库里面有非常强大的图形界面开发库，但是Qt库是C++语言开发的，PySide2、PyQt5可以让我们通过Python语言使用Qt。</p><p>但是 PySide2、PyQt5 这两者有什么区别呢？</p><p>可以形象地这样说： PySide2 是Qt的 <code>亲儿子</code> ， PyQt5 是Qt还没有亲儿子之前的收的 <code>义子</code> （Riverbank Computing这个公司开发的）。</p><p>那为什么 PyQt5 这个义子 反而比 PySide2 这个亲儿子更出名呢？</p><p>原因很简单：PySide2 这亲儿子最近（2018年7月）才出生。</p><p>但是亲儿子毕竟是亲儿子，Qt准备大力培养，PySide2 或许更有前途。</p><p>已经在使用 PyQt5 的朋友不要皱眉， 两个库的使用 对程序员来说，差别很小：它们的调用接口几乎一模一样。</p><p>如果你的程序是PyQt5开发的，通常只要略作修改，比如把导入的名字从 PyQt5 换成 PySide2 就行了。反之亦然。</p><p>以下内容只讨论PyQt5 。</p><h2 id="安装PyQt5"><a href="#安装PyQt5" class="headerlink" title="安装PyQt5"></a>安装PyQt5</h2><p>如果你选择PyQt5，直接执行</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyqt5-tools</span><br></pre></td></tr></table></figure><p>即可同时安装 PyQt5 和 一些重要的工具，比如 Qt designer。</p><h2 id="Qt-Designer-使用"><a href="#Qt-Designer-使用" class="headerlink" title="Qt Designer 使用"></a>Qt Designer 使用</h2><p>当控件较多时，再手写前端代码就比较费时，我们应该把大多数时间放在后端逻辑代码的优化上。除此之外，很多时候代码运行时界面呈现的样子并不是我们想要的，可能控件位置有偏差，可能觉得这种布局并没有那么好看，需要反复修改代码再运行预览。效率很低。</p><p>其实，我们可以用QT界面生成器 <code>Qt Designer</code> ，拖拖拽拽就可以直观的创建出程序大体的界面。</p><p>怎么运行这个工具呢？</p><p>运行 Python安装目录下 <code>Scripts\pyqt5designer.exe</code> 这个可执行文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/31/yEARpj.png">从左侧拖拽控件到右侧面板上进行界面设计，类似于Dreamvear。设计完成后生成一个.ui文件，里面是一个XML格式的界面定义。</p><p>比如设计界面如下（仅一个按钮）：</p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/31/yEA5n0.png" style="zoom:50%;" /><p>图形保存为一个ui文件，如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ui</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">class</span>&gt;</span>Form<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QWidget&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Form&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">x</span>&gt;</span>0<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">y</span>&gt;</span>0<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">width</span>&gt;</span>464<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">height</span>&gt;</span>422<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;windowTitle&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span>&gt;</span>Form<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QPushButton&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pushButton&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">x</span>&gt;</span>200<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">y</span>&gt;</span>150<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">width</span>&gt;</span>61<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">height</span>&gt;</span>61<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>button<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">resources</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">connections</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ui</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有两种方法来使用这个.ui文件。</p><h3 id="一、动态加载UI文件"><a href="#一、动态加载UI文件" class="headerlink" title="一、动态加载UI文件"></a>一、动态加载UI文件</h3><p>有了界面定义文件，我们就可以用一个Python程序来从文件中加载UI定义，并且动态创建一个相应的窗口对象，并“激活”窗口中的控件。</p><p>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget</span><br><span class="line"><span class="keyword">from</span> PyQt5.uic <span class="keyword">import</span> loadUi</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainForm</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        loadUi(<span class="string">&quot;D:\\test\\1\\test.ui&quot;</span>, self)  <span class="comment">#加载UI文件到self</span></span><br><span class="line">        <span class="comment">#self.resize(600,800)</span></span><br><span class="line">        self.setFixedSize(<span class="number">550</span>,<span class="number">550</span>)   <span class="comment"># 固定大小</span></span><br><span class="line">        self.slot_init()             <span class="comment"># 初始化槽函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;初始化所有槽函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slot_init</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pushButton.clicked.connect(self.AA)</span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 函数示例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AA</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app=QApplication(sys.argv)</span><br><span class="line">    w=MyMainForm()</span><br><span class="line">    w.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>运行结果：弹出刚才设计的界面，每点击一次按钮，就输出一句<code>hello</code></p><h3 id="二、转化UI文件为Python代码"><a href="#二、转化UI文件为Python代码" class="headerlink" title="二、转化UI文件为Python代码"></a>二、转化UI文件为Python代码</h3><p>还有一种使用UI文件的方式：先把UI文件直接转化为包含界面定义的Python代码文件，然后在你的程序中使用定义界面的类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyuic5 -x Frame.ui -o Frame.py</span><br></pre></td></tr></table></figure><p>这样就可以得到一个<code>Frame.py</code>文件，运行这个python代码就可以得到刚刚设计的界面，但点击按钮不会有反应，想要“激活”这个按钮，仍需要另一个python代码。</p><p>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> Frame <span class="keyword">import</span> Ui_Form</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainForm</span>(<span class="params">QMainWindow, Ui_Form</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyMainForm, self).__init__()</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line">        self.setFixedSize(<span class="number">550</span>,<span class="number">550</span>)   <span class="comment"># 固定大小</span></span><br><span class="line">        self.slot_init()             <span class="comment"># 初始化槽函数</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slot_init</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pushButton.clicked.connect(self.AA)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AA</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app=QApplication(sys.argv)</span><br><span class="line">    w=MyMainForm()</span><br><span class="line">    w.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>运行结果：弹出刚才设计的界面，每点击一次按钮，就输出一句<code>hello</code></p><p>那么我们该使用哪种方式比较好呢？动态加载还是转化为Python代码？</p><p>通常采用动态加载比较方便，因为改动界面后，不需要转化，直接运行，特别方便。</p><p>但是，如果 你的程序里面有非qt designer提供的控件， 这时候，需要在代码里面加上一些额外的声明，而且可能还会有奇怪的问题。往往就要采用 转化Python代码的方法。</p><blockquote><p><a href="http://www.python3.vip/">http://www.python3.vip/</a></p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序的用户交互界面，英文称之为 UI (user interface)&lt;/p&gt;
&lt;p&gt;当一个应用的 UI 比较复杂的时候，命令行方式就不便用户使用了，这时我们需要图形界面。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://hansy.tech/categories/Python/"/>
    
    <category term="PyQt5" scheme="https://hansy.tech/categories/Python/PyQt5/"/>
    
    
    <category term="Python可视化" scheme="https://hansy.tech/tags/Python%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Graham-Scan算法解决二维凸包问题</title>
    <link href="https://hansy.tech/2020/12/827871072.html"/>
    <id>https://hansy.tech/2020/12/827871072.html</id>
    <published>2020-12-25T05:32:06.000Z</published>
    <updated>2020-12-25T05:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><p>  凸包（Convex Hull）是一个计算几何（图形学）中的概念。点集Q的凸包是指一个最小凸多边形，满足Q中的点或者在多边形边上或者在其内。</p><a id="more"></a><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/12/25/rR4aCQ.jpg"></p><p>正式讨论凸包问题之前，这里先引入一个辅助概念——“方向”。</p><h4 id="有序点的方向"><a href="#有序点的方向" class="headerlink" title="有序点的方向"></a>有序点的方向</h4><p> 一个平面内有序点的方向（Orientation）可以有三种：</p><ul><li><p>逆时针 CounterClockwise</p></li><li><p>顺时针 Clockwise</p></li><li><p>共线 Colinear</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/12/25/rR4d3j.png"></p></li></ul><p>  对于点 $a(x_1, y_1)$、$b(x_2, y_2)$、$c(x_3, y_3)$，</p><p>线段ab的斜率为<br>$$<br>\sigma = \frac{y_2 - y_1}{x_2 - x_1}<br>$$<br>线段bc的斜率为<br>$$<br>\tau = \frac{y_3 - y_2}{x_3 - x_2}<br>$$</p><ul><li>若$\sigma &lt; \tau$，方向是逆时针（向左转）</li><li>若$\sigma = \tau$，方向是共线</li><li>若$\sigma &gt; \tau$，方向是顺时针（向右转）</li></ul><p>  因此，三个有序点的方向依赖于表达式（通分得到）<br>$$<br>(y_2 - y_1) \times (x_3 - x_2) - (y_3 - y_2) \times (x_2 - x_1)<br>$$</p><ul><li>若表达式为负，方向是逆时针</li><li>若表达式为0，方向是共线</li><li>若表达式为正，方向是顺时针</li></ul><h2 id="Graham-Scan"><a href="#Graham-Scan" class="headerlink" title="Graham Scan"></a>Graham Scan</h2><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/12/25/rRIvHP.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/12/25/rWZAMQ.gif"></p><p>算法可以分为两个主要部分：</p><ol><li><p>预处理</p><ol><li><p>找到最左下方的点。使该点 p0 作为输出凸包的第一个元素 points[0]。</p></li><li><p>将剩下的 n - 1 个点按照与p0的极角序排序，若有角度相同，仅保留距离 p0 最远的那个点</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/12/25/rR4wgs.png"></p></li></ol></li><li><p>接受或拒绝点</p><ol><li><p>创建空栈 S，将 【栈顶的下一个点、位于栈顶的点 】 入栈。</p></li><li><p>处理剩余的每个 points[i]：</p></li><li><p>追踪当前的三个点：栈顶的下一个点、位于栈顶的点，当前分析的点points[i]。三点之间有两条连线，看作是两个向量，计算他们之间的叉积，返回三点之间的关系：</p><p>  &lt;0，说明第三个点是向左转，则保留第二个点（栈顶元素），将第三个点进栈</p><p>  &gt;0，说明第三个点是向右转，则删除第二个点（栈顶元素），再将第三个点进栈</p><p>  =0，说明三点共线（可采用&gt;0的处理方式）</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/12/25/rR4N4g.png"></p></li></ol></li></ol><p>  </p><p>算法的第 1.1 步（找到最左下方的点）花 O(n) 时间，第 1.2 步（点的排序）花 O(n * logn) 时间。</p><p>第 2 个步骤中，每个元素入栈和出栈最多一次，假设栈操作 O(1) 时间，则第 2 步总共花 O(n) 时间。因此总体的时间复杂度是 O(n * logn)。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">points = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span>(<span class="params">file</span>):</span></span><br><span class="line">    points = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            key, x, y = line.strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            points.append([<span class="built_in">int</span>(key), <span class="built_in">float</span>(x), <span class="built_in">float</span>(y)])   <span class="comment"># 每行的代表一个点，三个值分别为：编号、横坐标、纵坐标</span></span><br><span class="line">    <span class="keyword">return</span> points</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别求出后面n-1个点与出发点的斜率，借助sorted完成从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params"><span class="built_in">next</span></span>):</span></span><br><span class="line">    start = points[<span class="number">0</span>]  <span class="comment"># 第一个点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按极角序排列的方法，但现在输入的坐标点是笛卡尔坐标点。不适合用这个</span></span><br><span class="line">    <span class="comment"># angle = math.atan2( start[2] - next[2], start[1] - next[1] )</span></span><br><span class="line">    <span class="comment"># return angle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按斜率排列的方法</span></span><br><span class="line">    <span class="keyword">if</span> start[<span class="number">1</span>] == <span class="built_in">next</span>[<span class="number">1</span>]:  <span class="comment"># 如果x坐标相同，那么求斜率时会出现分母为0的情况,直接返回斜率无穷大</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">99999</span></span><br><span class="line">    slope = (start[<span class="number">2</span>] - <span class="built_in">next</span>[<span class="number">2</span>]) / (start[<span class="number">1</span>] - <span class="built_in">next</span>[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> slope</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Graham_Scan</span>(<span class="params">points</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># points.sort(key=lambda x:x[1])   # 按横坐标排序的方法（和维基伪代码思想不太一致，弃用）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找到最左边且最下面的点作为出发点，和第一位互换</span></span><br><span class="line">    Min=<span class="number">9999</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> points:</span><br><span class="line">        <span class="comment"># 寻找最下边的点</span></span><br><span class="line">        <span class="keyword">if</span> i[<span class="number">1</span>]&lt;Min:</span><br><span class="line">            Min = i[<span class="number">1</span>]</span><br><span class="line">            index = i[<span class="number">0</span>]-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果同在最左边，可取y值更小的</span></span><br><span class="line">        <span class="keyword">elif</span> i[<span class="number">1</span>]==Min:</span><br><span class="line">            <span class="keyword">if</span> i[<span class="number">2</span>]&lt;=points[index][<span class="number">2</span>]:</span><br><span class="line">                Min = i[<span class="number">1</span>]</span><br><span class="line">                index = i[<span class="number">0</span>]-<span class="number">1</span></span><br><span class="line">    <span class="comment"># 和第一位互换位置</span></span><br><span class="line">    temp = points[<span class="number">0</span>]</span><br><span class="line">    points[<span class="number">0</span>] = points[index]</span><br><span class="line">    points[index] = temp</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前半部分是出发点  ；  后半部分是经过按斜率排序之后的n-1个坐标点     注意： “+”是拼接的含义，不是数值相加</span></span><br><span class="line">    points = points[:<span class="number">1</span>] + <span class="built_in">sorted</span>(points[<span class="number">1</span>:], key=compute)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    # 计算两个向量之间的叉积。返回三点之间的关系：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;0，说明第三个点是向左转，则保留第二个点（栈顶元素）</span></span><br><span class="line"><span class="string">    &gt;0，说明第三个点是向右转，则删除第二个点（栈顶元素）</span></span><br><span class="line"><span class="string">    =0，说明三点共线</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ccw</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (b[<span class="number">2</span>] - a[<span class="number">2</span>]) * (c[<span class="number">1</span>] - b[<span class="number">1</span>])   -    (c[<span class="number">2</span>] - b[<span class="number">2</span>]) * (b[<span class="number">1</span>] - a[<span class="number">1</span>]) </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用列表模拟一个栈。（最先加入的是前两个点，前两次while必定不成立，从而将点加进去）</span></span><br><span class="line">    convex_hull = []</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> points:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 如果能顺时针方向（右转）连接第三个顶点，就删除栈顶元素再加入这个顶点 ； 否则（向左转才达到第三个顶点），直接加入这个顶点  </span></span><br><span class="line"><span class="string">        convex_hull[-2]：栈顶元素下面的元素</span></span><br><span class="line"><span class="string">        convex_hull[-1]：栈顶元素</span></span><br><span class="line"><span class="string">        p：要分析的第三个顶点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(convex_hull) &gt; <span class="number">1</span> <span class="keyword">and</span> ccw(convex_hull[-<span class="number">2</span>], convex_hull[-<span class="number">1</span>], p) &gt;= <span class="number">0</span>:</span><br><span class="line">            convex_hull.pop()</span><br><span class="line">        convex_hull.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> convex_hull</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    points = read_file(<span class="string">&#x27;input.txt&#x27;</span>)</span><br><span class="line">    hull = Graham_Scan(points)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> hull:</span><br><span class="line">        print(i[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><strong>input.txt</strong>内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1,3.6,2.4</span><br><span class="line">2,5,0</span><br><span class="line">3,3.1,-2.2</span><br><span class="line">4,2.8,0.8</span><br><span class="line">5,0,0</span><br><span class="line">6,1.7,1.5</span><br><span class="line">7,0.4,2.6</span><br><span class="line">8,1.9,-0.8</span><br></pre></td></tr></table></figure><p><strong>输出：</strong>（代表连接顺序）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[5, 0.0, 0.0]</span><br><span class="line">[3, 3.1, -2.2]</span><br><span class="line">[2, 5.0, 0.0]</span><br><span class="line">[1, 3.6, 2.4]</span><br><span class="line">[7, 0.4, 2.6]</span><br></pre></td></tr></table></figure><p><strong>大致的图像为：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/12/25/rRXb36.jpg"></p><blockquote><p><a href="https://ysw1912.github.io/post/algorithm/2d_convex_hull/">https://ysw1912.github.io/post/algorithm/2d_convex_hull/</a></p><p><a href="https://en.wikipedia.org/wiki/Graham_scan">https://en.wikipedia.org/wiki/Graham_scan</a></p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;凸包&quot;&gt;&lt;a href=&quot;#凸包&quot; class=&quot;headerlink&quot; title=&quot;凸包&quot;&gt;&lt;/a&gt;凸包&lt;/h2&gt;&lt;p&gt;  凸包（Convex Hull）是一个计算几何（图形学）中的概念。点集Q的凸包是指一个最小凸多边形，满足Q中的点或者在多边形边上或者在其内。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://hansy.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="凸包问题" scheme="https://hansy.tech/tags/%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>使用pyinstaller打包时遇到的错误</title>
    <link href="https://hansy.tech/2020/12/546524728.html"/>
    <id>https://hansy.tech/2020/12/546524728.html</id>
    <published>2020-12-20T06:47:14.000Z</published>
    <updated>2020-12-20T06:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>多文件用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller --clean -F call_Frame.py -p Frame.py -p 1.py -p 2.py -p 3.py</span><br></pre></td></tr></table></figure><p>-F：代表只生成一个exe文件。   如果想生成一堆，用“-D”<br>-w：如果加上-w，代表去除黑框<br>–clean：去除缓存</p><p>生成exe后，双击运行，如果没有加黑框，有错误也不知道是什么错误；即使加黑框了，错误也只能一闪而过，怎么办？</p><p>答：切换到exe所在目录，直接输入<code>xxx.exe</code>回车，错误就能停留在黑框上（所以说第一次打包时最好带着黑框，等到没有错误了再去掉黑框打包一次）</p><h4 id="比如程序需要读取一个模型或一个txt文件之类的，程序报找不到这个文件"><a href="#比如程序需要读取一个模型或一个txt文件之类的，程序报找不到这个文件" class="headerlink" title="比如程序需要读取一个模型或一个txt文件之类的，程序报找不到这个文件"></a>比如程序需要读取一个模型或一个txt文件之类的，程序报找不到这个文件</h4><p>把程序所要用的外部资源文件移动到<code>dist</code>文件夹下，即和exe文件并列放置</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/12/20/ranban.png"></p><p>第15行对应的是：import torch</p><p>解决方法：</p><p><a href="https://github.com/pyinstaller/pyinstaller/issues/2666#issuecomment-508013383">使用pip来重新安装torch</a>（最好新建环境重新弄）</p><h4 id="报ucrtbase-DLL异常"><a href="#报ucrtbase-DLL异常" class="headerlink" title="报ucrtbase.DLL异常"></a>报ucrtbase.DLL异常</h4><p>解决方法：降级pyinstaller到3.3.1</p><h4 id="pyinstaller打包报错：-RecursionError-maximum-recursion-depth-exceeded"><a href="#pyinstaller打包报错：-RecursionError-maximum-recursion-depth-exceeded" class="headerlink" title="pyinstaller打包报错： RecursionError: maximum recursion depth exceeded"></a>pyinstaller打包报错： RecursionError: maximum recursion depth exceeded</h4><p>解决方法：</p><p>打包失败，但是会产生一个xxx.spec文件</p><p>在xxx.spec文件中增加两行(添加在<code># -*- mode: python ; coding: utf-8 -*-</code>这一行之后):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.setrecursionlimit(5000)</span><br></pre></td></tr></table></figure><p>最后执行：<code>pyinstaller xxx.spec</code>。就可以了</p><h4 id="UnicodeDecodeError-‘utf-8’-codec-can’t-decode-byte-0xce-in-position-126-in"><a href="#UnicodeDecodeError-‘utf-8’-codec-can’t-decode-byte-0xce-in-position-126-in" class="headerlink" title="UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xce in position 126: in"></a>UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xce in position 126: in</h4><p>在打包的命令行中先输入<code>chcp 65001</code> 然后再输入打包命令。 </p><h4 id="PermissionError-Errno-13-Permission-denied-…"><a href="#PermissionError-Errno-13-Permission-denied-…" class="headerlink" title="PermissionError: [Errno 13] Permission denied: …"></a>PermissionError: [Errno 13] Permission denied: …</h4><p>用管理员的身份打开cmd.exe</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="踩坑&amp;填坑" scheme="https://hansy.tech/categories/%E8%B8%A9%E5%9D%91-%E5%A1%AB%E5%9D%91/"/>
    
    
  </entry>
  
  <entry>
    <title>pytorch模型转换为onnx</title>
    <link href="https://hansy.tech/2020/12/2497714416.html"/>
    <id>https://hansy.tech/2020/12/2497714416.html</id>
    <published>2020-12-03T07:46:02.000Z</published>
    <updated>2020-12-03T07:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>netron 是一个非常好用的网络结构可视化工具。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/12/03/DTO8u4.png" alt="作者demo">(<a href="https://github.com/lutzroeder/netron">https://github.com/lutzroeder/netron</a>)</p><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install netron</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> netron</span><br><span class="line">netron.start(<span class="string">&#x27;my.pth&#x27;</span>)</span><br></pre></td></tr></table></figure><p>但是netron对pytorch模型的支持还不成熟。自己试的效果是生成的模型图没有连线。</p><p>​                                                   <img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/12/03/DTq5Jf.png"></p><p>所以这里就有一个把pth模型转化为onnx模型。</p><h3 id="Pytorch模型转onnx"><a href="#Pytorch模型转onnx" class="headerlink" title="Pytorch模型转onnx"></a>Pytorch模型转onnx</h3><h5 id="如果保存的是整个模型"><a href="#如果保存的是整个模型" class="headerlink" title="如果保存的是整个模型"></a>如果保存的是整个模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line">model = torch.load(<span class="string">&quot;test.pth&quot;</span>) <span class="comment"># pytorch模型加载</span></span><br><span class="line">batch_size = <span class="number">1</span>  <span class="comment">#批处理大小</span></span><br><span class="line">input_shape = (<span class="number">3</span>, <span class="number">244</span>, <span class="number">384</span>)   <span class="comment">#输入数据,改成自己的输入shape</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># #set the model to inference mode</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">x = torch.randn(batch_size, *input_shape)   <span class="comment"># 生成张量</span></span><br><span class="line">x = x.to(device)</span><br><span class="line">export_onnx_file = <span class="string">&quot;test.onnx&quot;</span><span class="comment"># 目的ONNX文件名</span></span><br><span class="line">torch.onnx.export(model</span><br><span class="line">                    x,</span><br><span class="line">                    export_onnx_file,</span><br><span class="line">                    opset_version=<span class="number">10</span>,</span><br><span class="line">                    do_constant_folding=<span class="literal">True</span>,<span class="comment"># 是否执行常量折叠优化</span></span><br><span class="line">                    input_names=[<span class="string">&quot;input&quot;</span>],<span class="comment"># 输入名</span></span><br><span class="line">                    output_names=[<span class="string">&quot;output&quot;</span>],<span class="comment"># 输出名</span></span><br><span class="line">                    dynamic_axes=&#123;<span class="string">&quot;input&quot;</span>:&#123;<span class="number">0</span>:<span class="string">&quot;batch_size&quot;</span>&#125;,  <span class="comment"># 批处理变量</span></span><br><span class="line">                                    <span class="string">&quot;output&quot;</span>:&#123;<span class="number">0</span>:<span class="string">&quot;batch_size&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><h5 id="如果保存的是模型参数"><a href="#如果保存的是模型参数" class="headerlink" title="如果保存的是模型参数"></a>如果保存的是模型参数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> net <span class="keyword">import</span> Model</span><br><span class="line"></span><br><span class="line">torch_model = torch.load(<span class="string">&quot;test.pth&quot;</span>,map_location=<span class="string">&#x27;cpu&#x27;</span>) <span class="comment"># pytorch模型加载</span></span><br><span class="line"></span><br><span class="line">model = Model()</span><br><span class="line"></span><br><span class="line">model.load_state_dict(torch_model) </span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">1</span>  <span class="comment">#批处理大小</span></span><br><span class="line">input_shape = (<span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>)   <span class="comment">#输入数据,改成自己的输入shape</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># #set the model to inference mode</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">x = torch.randn(batch_size, *input_shape)<span class="comment"># 生成张量</span></span><br><span class="line">export_onnx_file = <span class="string">&quot;test.onnx&quot;</span><span class="comment"># 目的ONNX文件名</span></span><br><span class="line">torch.onnx.export(model,</span><br><span class="line">                    x,</span><br><span class="line">                    export_onnx_file,</span><br><span class="line">                    opset_version=<span class="number">10</span>,</span><br><span class="line">                    do_constant_folding=<span class="literal">True</span>,<span class="comment"># 是否执行常量折叠优化</span></span><br><span class="line">                    input_names=[<span class="string">&quot;input&quot;</span>],<span class="comment"># 输入名</span></span><br><span class="line">                    output_names=[<span class="string">&quot;output&quot;</span>],<span class="comment"># 输出名</span></span><br><span class="line">                    dynamic_axes=&#123;<span class="string">&quot;input&quot;</span>:&#123;<span class="number">0</span>:<span class="string">&quot;batch_size&quot;</span>&#125;,  <span class="comment"># 批处理变量</span></span><br><span class="line">                                    <span class="string">&quot;output&quot;</span>:&#123;<span class="number">0</span>:<span class="string">&quot;batch_size&quot;</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> netron</span><br><span class="line">netron.start(<span class="string">&#x27;my.onnx&#x27;</span>)</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/12/03/DTO4xS.png"></p><p><strong>附注：模型转换工具</strong></p><p><a href="https://convertmodel.com/">一键转换 Caffe, ONNX, TensorFlow 到 NCNN, MNN, Tengineconvertmodel.com</a></p><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/159379768">https://zhuanlan.zhihu.com/p/159379768</a></p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Pytorch学习" scheme="https://hansy.tech/categories/Pytorch%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>全排列相关</title>
    <link href="https://hansy.tech/2020/12/4122935605.html"/>
    <id>https://hansy.tech/2020/12/4122935605.html</id>
    <published>2020-12-03T07:32:56.000Z</published>
    <updated>2020-12-03T07:32:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>用<strong>子集树</strong>实现全排列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: i不能作为全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k,n;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x[k]=i;</span><br><span class="line">                vis[i]=<span class="number">1</span>;</span><br><span class="line">                dfs(k+<span class="number">1</span>);</span><br><span class="line">                vis[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<strong>排列树</strong>实现全排列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: x数组必须先赋值</span></span><br><span class="line"><span class="comment">//i不能作为全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k,n;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(x[i],x[k]);</span><br><span class="line">            <span class="comment">// 如果有剪枝函数的话，写在这里。  只把 “dfs(k+1);” 语句写在if语句里面</span></span><br><span class="line">            dfs(k+<span class="number">1</span>);</span><br><span class="line">            swap(x[i],x[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        x[i]=i;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全排列的生成会有两个问题，分别是重复问题和镜像问题。以排列树为例，引出去重复和去镜像策略。</p><h4 id="去重复"><a href="#去重复" class="headerlink" title="去重复"></a>去重复</h4><ol><li><p>方案一</p><p>回溯前先对原始序列进行排序。如果当前的数与它前一个相等，则不允许当前的数执行swap动作。</p><p>核心在于比较的是当前位和前一位是否相等，这样就能保证<strong>对于重复的元素，有且仅有第一个出现的进行交换</strong>。保证重复元素只使用一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k,n;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=k &amp;&amp; x[i]==x[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            swap(x[i],x[k]);</span><br><span class="line">            dfs(k+<span class="number">1</span>);</span><br><span class="line">            swap(x[i],x[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x[i];</span><br><span class="line">    sort(x,x+n);</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方案二</p><p>若想选第i个数交换到k位置上，需要判断 (i,n] 这一区间中是否有与第i个数相等的元素。若有，则不允许第i个数交换过来。跳过这个i就可以，毕竟后面还有“i”。这样就能保证<strong>对于重复的元素，有且仅有最后一个出现的进行交换</strong>。保证重复元素只使用一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k,n;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=j+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i]==x[j])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!check(i))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            swap(x[i],x[k]);</span><br><span class="line">            dfs(k+<span class="number">1</span>);</span><br><span class="line">            swap(x[i],x[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x[i];</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方案三</p><p>若想选第i个圆到k位置上，需要判断[k,i)这一区间中是否有圆与第i个圆等大。如有，则不允许第i个圆换过来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k,n;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start ; i&lt;end ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i]==x[end])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!check(k,i))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            swap(x[i],x[k]);</span><br><span class="line">            dfs(k+<span class="number">1</span>);</span><br><span class="line">            swap(x[i],x[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x[i];</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="去镜像"><a href="#去镜像" class="headerlink" title="去镜像"></a>去镜像</h4><p>思路：在每个序列生成的过程中，时刻保证第一位小于最后一位，就不会出现镜像，可以少考虑一半的数。</p><p>办法：先为第一位从n个数中挑选一个数，然后从剩下的n-1个数里为第n位选一个比第一位大的数，然后正常的生成2~n-1这一区间的全排列。</p><p>生成完这n-2个数之后，就得到了一个解。改变第n个数，继续正常的生成2~n-1这一区间的全排列。直到第n位已经没有别的可用的数，去更换第1位数，再重复执行上述所有过程…</p><blockquote><p>注意：如果去镜像前没有去重复，那么去镜像操作不会有减半效果。</p></blockquote>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k,n,flag;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n-flag;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span> || flag)    <span class="comment">// flag的作用是保证正常的进行[2,n-1]区间的全排列的生成</span></span><br><span class="line">            &#123;</span><br><span class="line">                swap(x[i],x[k]);</span><br><span class="line">                dfs(k+<span class="number">1</span>);</span><br><span class="line">                swap(x[i],x[k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (x[i] &gt; x[<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(x[i],x[n]);</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    dfs(<span class="number">2</span>);</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                    swap(x[i],x[n]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x[i];</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://hansy.tech/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法整理" scheme="https://hansy.tech/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>使用pytorchviz画出好看的Pytorch模型网络结构</title>
    <link href="https://hansy.tech/2020/11/22673424.html"/>
    <id>https://hansy.tech/2020/11/22673424.html</id>
    <published>2020-11-21T10:18:48.000Z</published>
    <updated>2020-11-21T10:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在Pytorch中可以使用tensorboardX画出网络结构图，但总觉得不太好看。<strong>pytorchviz</strong> 似乎是一个不错的选择。</p><a id="more"></a><h4 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchviz <span class="keyword">import</span> make_dot</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line">net = Model()</span><br><span class="line">x = Variable(torch.randn(<span class="number">3</span>,<span class="number">32</span>,<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">vis_graph = make_dot(net(x), params=<span class="built_in">dict</span>(net.named_parameters()))</span><br><span class="line">vis_graph.directory = <span class="string">&quot;Net_Structure&quot;</span>   <span class="comment"># 设置可视化文件的导出路径</span></span><br><span class="line">vis_graph.<span class="built_in">format</span> = <span class="string">&quot;png&quot;</span>       <span class="comment"># 如果不加这一句，生成的则是pdf</span></span><br><span class="line">vis_graph.view()</span><br></pre></td></tr></table></figure><p>如果单纯地<code>pip install torchviz</code>，会报以下错误：</p><blockquote><p>==graphviz.backend.ExecutableNotFound: failed to execute [‘dot’, ‘-Tpdf’, ‘-O’, ‘Digraph.gv’], make sure the Graphviz executables are on your systems’ PATH==</p></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>正确的方法：</p><ol><li><p>下载<a href="https://graphviz.gitlab.io/_pages/Download/Download_windows.html">package</a>并解压到本地，例如<code>D:/test</code>  .  我下载的是：<a href="https://www2.graphviz.org/Packages/stable/windows/10/msbuild/Release/Win32/graphviz-2.44.1-win32.zip">这个</a></p></li><li><p>Add <code>D:\test\Graphviz\bin</code> to User path</p></li><li><p>Add <code>D:\test\Graphviz\bin\dot.exe</code> to System Path</p></li><li><p>重启计算机</p></li></ol><p>再运行上面的程序后就会发现网络结构图会出现在一个pdf或png中</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/220403674?utm_source=wechat_session">https://zhuanlan.zhihu.com/p/220403674?utm_source=wechat_session</a></p><p><a href="https://stackoverflow.com/questions/35064304/runtimeerror-make-sure-the-graphviz-executables-are-on-your-systems-path-aft">https://stackoverflow.com/questions/35064304/runtimeerror-make-sure-the-graphviz-executables-are-on-your-systems-path-aft</a></p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Pytorch中可以使用tensorboardX画出网络结构图，但总觉得不太好看。&lt;strong&gt;pytorchviz&lt;/strong&gt; 似乎是一个不错的选择。&lt;/p&gt;</summary>
    
    
    
    <category term="Pytorch学习" scheme="https://hansy.tech/categories/Pytorch%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>快速幂算法</title>
    <link href="https://hansy.tech/2020/09/1355681494.html"/>
    <id>https://hansy.tech/2020/09/1355681494.html</id>
    <published>2020-09-30T10:36:29.000Z</published>
    <updated>2020-09-30T10:36:29.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>快速幂</strong>（<strong>Exponentiation by squaring</strong>，平方求幂）是一种简单而有效的小算法，它可以以 $O(logn)$ 的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。</p><a id="more"></a><hr><p>让我们先来思考一个问题：<strong>7的10次方，怎样算比较快？</strong></p><p><strong>方法1：</strong>最朴素的想法，7<em>7=49，49</em>7=343，… 一步一步算，共进行了<strong>9次</strong>乘法。</p><p>这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。</p><p><strong>方法2：</strong>先算7的5次方，即7<em>7</em>7<em>7</em>7，再算它的平方，共进行了<strong>5次</strong>乘法。</p><p>但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。</p><p><strong>方法3：</strong>先算7<em>7得49，则7的5次方为49</em>49*7，再算它的平方，共进行了<strong>4次</strong>乘法。</p><p>模仿这样的过程。如果有 $ x^n $，且 $n = 2^k$，那么原题可以很轻松的表示为：$x^n=(x^2)^2)^2…$。这样只要做k次平方运算就能解决，时间复杂度就从O(n)下降到log(n)。这就是快速幂。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="递归快速幂"><a href="#递归快速幂" class="headerlink" title="递归快速幂"></a>递归快速幂</h2><p>刚刚我们用到的，无非是一个<strong>二分</strong>的思路。我们很自然地可以得到一个递归方程：<br>$$<br>a^n=\begin{cases}a^{n-1}·a，&amp; {n%2==1}\a^\frac{n}{2}·a^\frac{n}{2}，&amp; {n%2==0 , n!=0}\1 ，&amp; {n=0}\\end{cases}<br>$$<br>计算a的n次方，如果n是偶数（不为0），那么就<strong>先计算a的n/2次方，然后平方</strong>；如果n是奇数，那么就<strong>先计算a的n-1次方，再乘上a</strong>；递归出口是<strong>a的0次方为1</strong>。</p><p>递归快速幂的思路非常自然，代码也很简单（直接把递归方程翻译成代码即可）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> qpow(a, n - <span class="number">1</span>) * a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = qpow(a, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> temp * temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这个temp变量是必要的，因为如果不把 $a^\frac{n}{2}$ 记录下来，直接写成<code>qpow(a, n /2)*qpow(a, n /2)</code>，那会计算两次 $a^\frac{n}{2}$，整个算法就退化为了 $O(n)$  ，就和正常的连续相乘没什么区别了。这是快速幂的核心所在。</p><p>&nbsp;</p><h5 id="递归快速幂求模"><a href="#递归快速幂求模" class="headerlink" title="递归快速幂求模"></a>递归快速幂求模</h5><p>在实际问题中，题目常常会要求对一个大素数取模，这是因为计算结果可能会非常巨大，但是在这里考察高精度又没有必要。这时我们的快速幂也应当进行取模，此时应当注意，原则是<strong>步步取模</strong>，如果MOD较大，还应当<strong>开long long</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归快速幂（对大素数取模）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> qpow(a, n - <span class="number">1</span>) * a % MOD;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll temp = qpow(a, n / <span class="number">2</span>) % MOD;</span><br><span class="line">        <span class="keyword">return</span> temp * temp % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家知道，递归虽然<strong>简洁</strong>，但会产生<strong>额外的空间开销</strong>。我们可以把递归改写为循环，来避免对栈空间的大量占用，也就是<strong>非递归快速幂</strong>。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="非递归快速幂"><a href="#非递归快速幂" class="headerlink" title="非递归快速幂"></a>非递归快速幂</h2><p>我们换一个角度来引入非递归的快速幂。还是7的10次方，但这次，我们把10写成<strong>二进制</strong>的形式，也就是 $(1010)_2$  。</p><p>现在我们要计算 $7^{(1010)_2}$  ，可以怎么做？我们很自然地想到可以把它拆分为  $7^{(1000)_2}·7^{(10)_2}$  . 实际上，对于任意的整数，我们都可以把它拆成若干个 $7^{(100…)_2}$ 的形式相乘。而这些 $7^{(100…)_2}$ ，恰好就是 $7^1$、$7^2$、$7^4$ ……我们只需<strong>不断把底数平方</strong>就可以算出它们。</p><p>我们先看代码，再来仔细推敲这个过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)        <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">            ans *= a;  <span class="comment">//ans乘上当前的a。</span></span><br><span class="line">        a *= a;        <span class="comment">//a自乘。  因为2进制中是以1.2.4.8.16为阶梯上涨的，所以直接乘以当前的</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的位运算符，**&gt;&gt;<strong>是右移，表示把二进制数</strong>往右移一位<strong>，相当于/2；&amp;是按位与，&amp;1可以理解为</strong>取出二进制数的最后一位**，相当于%2==1。这么一等价，是不是看出了递归和非递归的快速幂的关系了？虽然非递归快速幂因为牵扯到二进制理解起来稍微复杂一点，但基本思路其实和递归快速幂没有太大的出入。</p><p>&nbsp;</p><h5 id="非递归快速幂求模"><a href="#非递归快速幂求模" class="headerlink" title="非递归快速幂求模"></a>非递归快速幂求模</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)        <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">            ans = ans*a%m;  <span class="comment">//ans乘上当前的a</span></span><br><span class="line">        a = a*a%m;        <span class="comment">//a自乘</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><blockquote><p>算法学习笔记(4)：快速幂 - Pecco的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/95902286">https://zhuanlan.zhihu.com/p/95902286</a></p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;快速幂&lt;/strong&gt;（&lt;strong&gt;Exponentiation by squaring&lt;/strong&gt;，平方求幂）是一种简单而有效的小算法，它可以以 $O(logn)$ 的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://hansy.tech/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法整理" scheme="https://hansy.tech/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>八数码难题——A*</title>
    <link href="https://hansy.tech/2020/09/1611446403.html"/>
    <id>https://hansy.tech/2020/09/1611446403.html</id>
    <published>2020-09-28T11:24:50.000Z</published>
    <updated>2020-09-28T11:24:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>盲目搜索要求对某个状态的每一个方向都进行扩展。A*算法要求对某个状态的每一个方向都进行分析，但只扩展代价最小的那个子方向节点（如果有相同的则随机选择一个）。</p><a id="more"></a>  <img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/12/21/r0c2ZT.jpg" alt="r0c2ZT.jpg" style="zoom:58%;" /><p>代码由BFS版本的代码修改得到。</p><p>程序修改的方法就是在探索方向的for循环里顺便计算四个（最多四个）子方向的代价值，选择一个代价最小的方向作为最终的方向final去让空白格移动。然后判断新状态是否已分析，若没有，则进行原始的操作；若已经处理过了，则跳过。当然，这个过程要换到for循环外面。同时，因为选择的方向已经是最优的，所以操作以后不需要让空白格回退 。</p><p>有一个需要注意的地方：因为有 “代价相同时随机选择一个方向” 和 “只能处理先前未处理过的状态” 这两个要求。所以对于某些棋盘的最终步数，甚至是是否有可行解有很大影响。</p><h4 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.set_printoptions(threshold=np.inf)  <span class="comment"># threshold 指定超过多少使用省略号，np.inf代表无限大</span></span><br><span class="line"></span><br><span class="line">start = <span class="literal">None</span></span><br><span class="line">end = <span class="string">&#x27;123804765&#x27;</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;&#125;  <span class="comment"># 用来做状态处理的标记  相当于open表</span></span><br><span class="line">ans = np.zeros(<span class="number">400000</span>, dtype=<span class="built_in">int</span>)  <span class="comment"># 如果开的小，很多棋盘会解不出来</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求当前状态与目标状态的偏差代价</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bias</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>[i] != <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> end[i] != <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> <span class="built_in">str</span>[i] == end[i]:  <span class="comment"># 不把0算入在内</span></span><br><span class="line">            <span class="built_in">sum</span> = <span class="built_in">sum</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span> - <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述空白格移动</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params"><span class="built_in">str</span>, zero, to</span>):</span></span><br><span class="line">    temp = <span class="built_in">list</span>(<span class="built_in">str</span>)  <span class="comment"># 在python中，字符串是不可变的变量，所以先转化为list</span></span><br><span class="line">    temp[zero], temp[to] = temp[to], temp[zero]</span><br><span class="line">    now = <span class="string">&#x27;&#x27;</span>.join(temp)</span><br><span class="line">    <span class="keyword">return</span> now</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求初始状态的逆序数判断是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inversion</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):  <span class="comment"># 0-8</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>[j] &lt; <span class="built_in">str</span>[i] <span class="keyword">and</span> <span class="built_in">str</span>[j] != <span class="string">&#x27;0&#x27;</span>:  <span class="comment"># 不把0算入在内</span></span><br><span class="line">                <span class="built_in">sum</span> = <span class="built_in">sum</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 试探空白格移动的四个方向</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">i, index</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:  <span class="comment"># 向上</span></span><br><span class="line">        <span class="keyword">if</span> index - <span class="number">3</span> &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> index - <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">2</span>:  <span class="comment"># 向下</span></span><br><span class="line">        <span class="keyword">if</span> index + <span class="number">3</span> &lt;= <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">return</span> index + <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">3</span>:  <span class="comment"># 向左</span></span><br><span class="line">        <span class="keyword">if</span> index % <span class="number">3</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> index - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">4</span>:  <span class="comment"># 向右</span></span><br><span class="line">        <span class="keyword">if</span> index % <span class="number">3</span> != <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>(<span class="params">start</span>):</span></span><br><span class="line">    head, tail, flag = <span class="number">0</span>, <span class="number">1</span>, <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    q = queue.Queue()  <span class="comment"># 括号中是队列可容纳数据的多少，如果不设置，则可以一直增加</span></span><br><span class="line">    q.put(start)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> (q.empty() <span class="keyword">or</span> flag):</span><br><span class="line">        now = q.get()  <span class="comment"># 取出的时候顺带弹出了.  now现在是str类型</span></span><br><span class="line">        zero = now.find(<span class="string">&#x27;0&#x27;</span>)  <span class="comment"># 寻找0的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">min</span> = <span class="number">1000</span></span><br><span class="line">        print(<span class="string">&#x27;当前状态分支节点的代价情况：&#x27;</span>)</span><br><span class="line">        <span class="comment"># 向四个方向寻找</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">            to = move(i, zero)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> to == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            now = swap(now, zero, to)  <span class="comment"># 交换，计算当前状态其他方向的f(x)代价</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (now <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dict</span>) <span class="keyword">and</span> (now != start):  <span class="comment"># 对于已经分析过的状态（包括初始状态），不再计算它们的代价值</span></span><br><span class="line">                g = ans[head] + <span class="number">1</span>  <span class="comment"># 深度代价</span></span><br><span class="line">                h = bias(now)  <span class="comment"># 偏差代价</span></span><br><span class="line">                print(g, h)</span><br><span class="line"></span><br><span class="line">                f = g + h  <span class="comment"># 总代价</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> f &lt; <span class="built_in">min</span>:</span><br><span class="line">                    <span class="built_in">min</span> = f</span><br><span class="line">                    final = to</span><br><span class="line"></span><br><span class="line">            now = swap(now, zero, to)  <span class="comment"># 恢复现场，以便去计算原状态下一个方向的f(x)代价</span></span><br><span class="line">        print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        now = swap(now, zero, final)  <span class="comment"># 已寻找到最好的方向，交换</span></span><br><span class="line">        print(<span class="string">&#x27;step:&#x27;</span> + <span class="built_in">str</span>(ans[head] + <span class="number">1</span>) + <span class="string">&#x27;  移动后的状态：&#x27;</span> + now)</span><br><span class="line">        <span class="keyword">if</span> now <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dict</span>:</span><br><span class="line">            <span class="keyword">if</span> now == end:</span><br><span class="line">                print(ans[head] + <span class="number">1</span>, end=<span class="string">&#x27; steps&#x27;</span>)  <span class="comment"># 深度</span></span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            ans[tail] = ans[head] + <span class="number">1</span></span><br><span class="line">            tail = tail + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">dict</span>[now] = i  <span class="comment"># 该状态已分析过，做标记</span></span><br><span class="line">            q.put(now)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;因代价等量时遵循随机选择策略，导致没有其他未走过的路径可走&#x27;</span>)</span><br><span class="line">        <span class="comment"># now = swap(now, zero, final)  # 已经找到最好的方向了，不用再换过来</span></span><br><span class="line"></span><br><span class="line">        head = head + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># start = input()  # 输入初始状态</span></span><br><span class="line">    start = <span class="string">&#x27;283164705&#x27;</span>  <span class="comment"># 283104765：4     283164705：5   216408753：18   234150768：无解</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> start == end:</span><br><span class="line">        print(<span class="string">&#x27;已是终点状态&#x27;</span>)</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> inversion(start) % <span class="number">2</span> != inversion(end) % <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">&#x27;该状态无解&#x27;</span>)</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;初始状态：&#x27;</span> + start)</span><br><span class="line">    A(start)</span><br></pre></td></tr></table></figure><h4 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h4><p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202009/1534055-20200928191719622-477774338.bmp"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h4&gt;&lt;p&gt;盲目搜索要求对某个状态的每一个方向都进行扩展。A*算法要求对某个状态的每一个方向都进行分析，但只扩展代价最小的那个子方向节点（如果有相同的则随机选择一个）。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://hansy.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>八数码难题——BFS</title>
    <link href="https://hansy.tech/2020/09/2680138515.html"/>
    <id>https://hansy.tech/2020/09/2680138515.html</id>
    <published>2020-09-28T11:24:47.000Z</published>
    <updated>2020-09-28T11:24:47.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>3×3 九宫棋盘，放置数码为1 -8的8个棋牌，剩下一个空格。指定初始状态和目标状态，要求只能通过移动空白格来形成指定棋盘。求最短步数以及移动方法。<br>                                     <img src= "/img/loading.gif" data-lazy-src="http://r.photo.store.qq.com/psb?/V11WEso82HLlBR/IWuds*sj0KeR*c196REC3LQ7Dzea4m0URTOrOdtQfgc!/o/dHIBAAAAAAAA&bo=ywHXAMsB1wADACU!"></p><a id="more"></a><h4 id="核心问题：逆序数"><a href="#核心问题：逆序数" class="headerlink" title="核心问题：逆序数"></a>核心问题：逆序数</h4><p><strong>在八数码问题中，两个状态的逆序数奇偶性相同，他们之间才可达</strong>。</p><p>在这个题目中，初始状态和目标状态给定且逆序数都为奇，所以初始状态是合法的。同样的，在后续尝试每一个状态时，都需要判断该状态逆序数是否为奇数，若是，则可以对该节点继续扩展，否则该节点是非法节点，一定不可能移动到目标状态。</p><p>没进行一步就求一次逆序数是不是很耗时呢？实际上，在八数码问题中这个操作是多余的。原因很简单：首先在对矩阵编码时，我们把空白格看作是数字0，则状态序列是一个从0到8的序列，但要注意计算逆序数时是不把0元素包含在内的！它只是一个空白格位置的标记。</p><p>0元素在不出界的前提下总共有上下左右四种走法</p><ul><li>往左、右移动：数列1-8的相对位置没有任何变化，所以数列的逆序数不变。</li><li>往上、下移动：空白格在序列0-8中往前（后）移动了3个单位距离，相当于将一个数字X在数列1-8中向前（后）移动2格（3-1=2），那么跳过的这两个数，要么比数字X都要大（小），逆序数可能±2；要么一个比数字X大，一个比数字X小，逆序数不变（+1和-1正好抵消）。所以逆序数仍然不会改变</li></ul><p>由以上可知：在八数码问题中，无论空白格怎么移动，状态逆序数的奇偶性都不会改变。但不保证在n数码问题中也有这样的现象。例如4*4棋盘，在上下移动空白格时，逆序数会±3或者±1，其奇偶性必然发生改变。</p><h4 id="BFS解体思路"><a href="#BFS解体思路" class="headerlink" title="BFS解体思路"></a>BFS解体思路</h4><ol><li>判断初始状态是否和目标状态一致。若一致，程序结束；否则，转入步骤2。</li><li>判断初始状态（自由输入）的逆序数奇偶性是否和目标状态一致。若一致，转入步骤3；否则，程序结束。</li><li>状态入队，进入步骤4</li><li>如果队为空，则结束程序；若非空，则首元素（状态）出队并找到该状态下0元素的位置，分别分析四个方向的可行性。如果当前方向可行，则进入步骤5；否则继续寻找下一个方向，如果四个方向寻找完毕，则进入步骤9</li><li>已找到可行的位置to，执行 <code>swap(当前状态[zero],当前状态[to])</code>，即交换位置。进入步骤6.</li><li>判断该状态是否已经分析过（有标记），如果已经处理过，则进入步骤8；否则进入步骤7</li><li>判断该状态是否为目标状态，若是，则输出搜索深度<code>cnt[head]+1</code>作为最终结果并结束整个程序；若不是则执行<code>cnt[tail++] = cnt[head] + 1</code>并将该状态如队并作标记。进入步骤8 。</li><li>执行<code>swap(当前状态[zero],当前状态[to])</code>。进入步骤9</li><li><code>head++</code>  进入步骤4。</li></ol><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><p>标记深度</p><h4 id="小思考：给字符串做标记"><a href="#小思考：给字符串做标记" class="headerlink" title="小思考：给字符串做标记"></a>小思考：给字符串做标记</h4><p>我们知道：每一个处理过的状态都不能再次分析。每一个状态都是一个字符串形式，那怎么才能耗最少的空间标记这个string并用最少的时间查找呢？首先想到的就是存到一个大集合里然后每次查找，太蠢肯定不行。那用索引？但字符串不能当作下标啊！有办法吗？其实是有的。在c++中，可以使用<code>map&lt;string,bool&gt;m;</code>的方法，如果出现状态<code>now</code>，则标记<code>m[now]=True</code>，然后使用<code>if(!m[now])</code>判断即可。我们得到启发：这就是借用键值对的功能啊，用字符串作为键，用True作为值，这不就可以高效得实现对字符串的标记吗。 那在python中怎么用呢？</p><p>python中只有字典支持键值存储，那我们就大胆使用，处理过的标记为True，未处理的标记False。但这样真的高效吗？在判断时我们有必要每一个都区分True和False吗？其实我们只需要把出现过的字符串标记为True，没出现的不用管，在判断时只判断这个键（字符串）在字典中是否存在即可，而不用管它的值是什么，这样就减少了特别多的空间占用，另一方面，因为不用管键所对应的值是什么，我们完全可以标记字符串为<code>dict[now]=&#39;$&#39;</code>之类的，无任何影响。</p><h4 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.set_printoptions(threshold=np.inf)  <span class="comment"># threshold 指定超过多少使用省略号，np.inf代表无限大</span></span><br><span class="line"></span><br><span class="line">start = <span class="literal">None</span></span><br><span class="line">end = <span class="string">&#x27;123804765&#x27;</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;&#125;  <span class="comment"># 用来做状态处理的标记  相当于open表</span></span><br><span class="line">ans = np.zeros(<span class="number">400000</span>, dtype=<span class="built_in">int</span>)  <span class="comment"># 如果开的小，很多棋盘会解不出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述空白格移动</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params"><span class="built_in">str</span>, zero, to</span>):</span></span><br><span class="line">    temp = <span class="built_in">list</span>(<span class="built_in">str</span>)  <span class="comment"># 在python中，字符串是不可变的变量，所以先转化为list</span></span><br><span class="line">    temp[zero], temp[to] = temp[to], temp[zero]</span><br><span class="line">    now = <span class="string">&#x27;&#x27;</span>.join(temp)</span><br><span class="line">    <span class="keyword">return</span> now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求初始状态的逆序数判断是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inversion</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):  <span class="comment"># 0-8</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>[j] &lt; <span class="built_in">str</span>[i] <span class="keyword">and</span> <span class="built_in">str</span>[j] != <span class="string">&#x27;0&#x27;</span>:  <span class="comment"># 不把0算入在内</span></span><br><span class="line">                <span class="built_in">sum</span> = <span class="built_in">sum</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 试探空白格移动的四个方向</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">i, index</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:  <span class="comment"># 向上</span></span><br><span class="line">        <span class="keyword">if</span> index - <span class="number">3</span> &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> index - <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">2</span>:  <span class="comment"># 向下</span></span><br><span class="line">        <span class="keyword">if</span> index + <span class="number">3</span> &lt;= <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">return</span> index + <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">3</span>:  <span class="comment"># 向左</span></span><br><span class="line">        <span class="keyword">if</span> index % <span class="number">3</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> index - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">4</span>:  <span class="comment"># 向右</span></span><br><span class="line">        <span class="keyword">if</span> index % <span class="number">3</span> != <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span>(<span class="params">start</span>):</span></span><br><span class="line">    head, tail, flag = <span class="number">0</span>, <span class="number">1</span>, <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤3</span></span><br><span class="line">    q = queue.Queue()  <span class="comment"># 括号中是队列可容纳数据的多少，如果不设置，则可以一直增加</span></span><br><span class="line">    q.put(start)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤4</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> (q.empty() <span class="keyword">or</span> flag):</span><br><span class="line">        now = q.get()  <span class="comment"># 取出的时候顺带弹出了.  now现在是str类型</span></span><br><span class="line">        zero = now.find(<span class="string">&#x27;0&#x27;</span>)  <span class="comment"># 寻找0的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向四个方向寻找</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">            to = move(i, zero)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> to == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 步骤5</span></span><br><span class="line">            now = swap(now, zero, to)  <span class="comment"># 交换</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 步骤6</span></span><br><span class="line">            <span class="keyword">if</span> now <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dict</span>:</span><br><span class="line">                <span class="comment"># 步骤7</span></span><br><span class="line">                <span class="keyword">if</span> now == end:</span><br><span class="line">                    print(ans[head] + <span class="number">1</span>, end=<span class="string">&#x27; steps&#x27;</span>)  <span class="comment"># 深度</span></span><br><span class="line">                    flag = <span class="literal">True</span>  <span class="comment"># 用来跳出 while</span></span><br><span class="line">                    <span class="keyword">break</span>        <span class="comment"># 用来跳出 for</span></span><br><span class="line"></span><br><span class="line">                ans[tail] = ans[head] + <span class="number">1</span></span><br><span class="line">                tail = tail + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">dict</span>[now] = i  <span class="comment"># 该状态已分析过，做标记</span></span><br><span class="line">                q.put(now)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 步骤8</span></span><br><span class="line">            now = swap(now, zero, to)  <span class="comment"># 恢复现场</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步骤9</span></span><br><span class="line">        head = head + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># start = input()  # 输入初始状态</span></span><br><span class="line">    start = <span class="string">&#x27;216408753&#x27;</span>  <span class="comment"># 283104765：4     283164705：5   216408753：18   234150768：无解</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤1</span></span><br><span class="line">    <span class="keyword">if</span> start == end:</span><br><span class="line">        print(<span class="string">&#x27;已是终点状态&#x27;</span>)</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤2</span></span><br><span class="line">    <span class="keyword">if</span> inversion(start) % <span class="number">2</span> != inversion(end) % <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">&#x27;该状态无解&#x27;</span>)</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line">    BFS(start)</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h4&gt;&lt;p&gt;3×3 九宫棋盘，放置数码为1 -8的8个棋牌，剩下一个空格。指定初始状态和目标状态，要求只能通过移动空白格来形成指定棋盘。求最短步数以及移动方法。&lt;br&gt;                                     &lt;img src=&quot;http://r.photo.store.qq.com/psb?/V11WEso82HLlBR/IWuds*sj0KeR*c196REC3LQ7Dzea4m0URTOrOdtQfgc!/o/dHIBAAAAAAAA&amp;bo=ywHXAMsB1wADACU!&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://hansy.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>使用全排列的思想解决n皇后问题</title>
    <link href="https://hansy.tech/2020/09/456166021.html"/>
    <id>https://hansy.tech/2020/09/456166021.html</id>
    <published>2020-09-19T11:22:36.000Z</published>
    <updated>2020-09-19T11:22:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><a id="more"></a><p>全排列:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k,n;</span><br><span class="line"><span class="keyword">int</span> queen[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;queen[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                queen[k]=i;</span><br><span class="line">                x[i]=<span class="number">1</span>;</span><br><span class="line">                dfs(k+<span class="number">1</span>);</span><br><span class="line">                x[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>N皇后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span>  queen[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检验第k行的第i列上是否可以摆放皇后</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> i)</span>      </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;k; j++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        第一个条件是判断是否在同一列（也可以用visit[i]数组替代）；</span></span><br><span class="line"><span class="comment">        第二个条件是判断是否在同一斜线上，依据是计算这两个点之间的水平与垂直距离是否相等；</span></span><br><span class="line"><span class="comment">                abs(queen[j] - i)是计算当前想插入的点与当前正在检查的点之间的水平距离，k-j 是计算二者之间的垂直距离。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="keyword">if</span> ((queen[j] == i) || <span class="built_in">abs</span>(queen[j] - i) == (k-j))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;queen[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (k == n + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">show();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check(k, i))       <span class="comment">//也可以在判断条件里加上“visit[i]==0”来检查是否有同意行或列的情况，但这里可以在check函数的for循环里用一个(queen[j] == i)来代替，可以达到同样的效果还减少了visit数组的开辟</span></span><br><span class="line">&#123;</span><br><span class="line">queen[k] = i;</span><br><span class="line">dfs(k + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用全排列的思想解决n皇后问题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://cloud.tencent.com/developer/article/1176997">https://cloud.tencent.com/developer/article/1176997</a></p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://hansy.tech/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法整理" scheme="https://hansy.tech/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>修改xml内容+重命名</title>
    <link href="https://hansy.tech/2020/09/1792077113.html"/>
    <id>https://hansy.tech/2020/09/1792077113.html</id>
    <published>2020-09-15T05:32:48.000Z</published>
    <updated>2020-09-15T05:32:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_xml</span>(<span class="params">xml_path</span>):</span></span><br><span class="line">    filelist = os.listdir(xml_path)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> xmlfile <span class="keyword">in</span> filelist:</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 获取xml结点</span></span><br><span class="line">        doc = ET.parse(xml_path+xmlfile)</span><br><span class="line">        root = doc.getroot()</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 修改xml中的filename部分</span></span><br><span class="line">        sub1 = root.find(<span class="string">&#x27;filename&#x27;</span>) </span><br><span class="line">        name = sub1.text</span><br><span class="line">        name = <span class="built_in">list</span>(name)       <span class="comment"># 再python中不允许直接修改字符串，这里转化为list进行修改,而后再转成字符串</span></span><br><span class="line">        name[-<span class="number">8</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        sub1.text = <span class="string">&quot;&quot;</span>.join(name)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 修改xml中的path部分</span></span><br><span class="line">        sub2 = root.find(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line">        path = sub2.text</span><br><span class="line">        path = <span class="built_in">list</span>(path)</span><br><span class="line">        path[-<span class="number">8</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        sub2.text = <span class="string">&quot;&quot;</span>.join(path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 保存修改</span></span><br><span class="line">        doc.write(xml_path+xmlfile)   </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 文件重命名</span></span><br><span class="line">        new = sub1.text.rsplit(<span class="string">&#x27;.&#x27;</span>,<span class="number">1</span>)[<span class="number">0</span>]       <span class="comment"># 去除后缀。注意 split和rsplit用法的区别</span></span><br><span class="line">        os.rename(xml_path+xmlfile , xml_path+new+<span class="string">&#x27;.xml&#x27;</span>)     <span class="comment"># 不能只写文件名不写具体的路径</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">xml_path = <span class="string">&#x27;D:\\home\\2\\beifen\\&#x27;</span></span><br><span class="line">change_xml(xml_path) </span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="其他" scheme="https://hansy.tech/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Python应用" scheme="https://hansy.tech/tags/Python%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>pytorch的pth权重转化为tensorflow的ckpt文件</title>
    <link href="https://hansy.tech/2020/08/2789207887.html"/>
    <id>https://hansy.tech/2020/08/2789207887.html</id>
    <published>2020-08-11T12:42:55.000Z</published>
    <updated>2020-08-11T12:42:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">bin_path, ckptpath</span>):</span></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        <span class="keyword">for</span> var_name, value <span class="keyword">in</span> torch.load(bin_path, map_location=<span class="string">&#x27;cpu&#x27;</span>).items():</span><br><span class="line">            print(var_name)  <span class="comment"># 输出权重文件中的变量名</span></span><br><span class="line">            tf.Variable(initial_value=value, name=var_name)</span><br><span class="line">        saver = tf.train.Saver()</span><br><span class="line">        sess.run(tf.global_variables_initializer())</span><br><span class="line">        saver.save(sess, ckpt_path)</span><br><span class="line"></span><br><span class="line">bin_path = <span class="string">&#x27;model.pth&#x27;</span></span><br><span class="line">ckpt_path = <span class="string">&#x27;new_model.ckpt&#x27;</span></span><br><span class="line">convert(bin_path, ckpt_path)</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Pytorch学习" scheme="https://hansy.tech/categories/Pytorch%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>蚁群算法</title>
    <link href="https://hansy.tech/2020/08/803160622.html"/>
    <id>https://hansy.tech/2020/08/803160622.html</id>
    <published>2020-08-04T07:17:15.000Z</published>
    <updated>2020-08-04T07:17:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>​        蚁群算法（Ant Colony Algorithm）最初于1992年由意大利学者M.Dorigo等人提出，它是一种模拟自然界中真实蚁群觅食行为的仿生优化算法。研究发现：每只蚂蚁觅食时在走过的路线上会留下一种称为信息素的物质，蚂蚁之间靠感知这种物质的浓度进行信息传递。蚂蚁在选择路径时总是倾向于朝信息索浓度高的方向移动，而距离短的路径上走过的蚂蚁多，留下的信息素也多，后续蚂蚁选择它的概率也会越大；其他路径上的信息素会随着时间的推移不断挥发，这样就形成了一种正反馈机制，最后整个蚁群聚集到最短路径上。</p><p>​        人工蚁群算法模拟了这一过程。每只蚂蚁在解空间独立地搜索可行解，解越好留下的信息素越多，随着算法推进，较优解路径上的信息素增多，选择它的蚂蚁也随之增多，最终收敛到最优或近似最优的解上。</p><a id="more"></a><p>&nbsp;</p><p>&nbsp;</p><h2 id="一、算法原理"><a href="#一、算法原理" class="headerlink" title="一、算法原理"></a>一、算法原理</h2><p>​        蚂蚁系统是最早的蚁群系统，它采用 $\tau_{ij}(t)$ 来模仿t时刻路径 $i$ 到 $j$ 上面的信息残留量，即信息素浓度。类似于蚂蚁觅食过程，每条路径上面的信息素会挥发，如果有蚂蚁经过的时候，信息素的浓度会相应增加。因此，蚂蚁系统中的信息素浓度的更新公式为：<br>$$<br>\tau_{ij}(t+n)=\rho·\tau_{ij}(t)+\Delta\tau_{ij}<br>$$<br>式中，$\rho$ 是一个 $0$ 到 $1$ 的数字，$(1-\rho)$ 为挥发因子。另外，$\Delta\tau_{ij}$ 表示一次旅行（遍历完所有城市）后，所有路径i到j的蚂蚁留下的信息素总量，即：<br>$$<br>\Delta\tau_{ij}=\sum_{k=1}^m\Delta\tau_{ij}^kr<br>$$<br>式中，$\Delta\tau_{ij}^k$ 表示第k只蚂蚁在路径 $i$ 到 $j$ 上面留下的信息素量。如果第 $k$ 只蚂蚁经过路径 $i$ 到 $j$ ，则：<br>$$<br>\Delta\tau_{ij}^k=\frac{Q}{L_kr}<br>$$<br>式中，$Q$ 为一个常数，$L_k$ 为蚂蚁已经走过路径的总长度。否则，第 $k$ 只蚂蚁在 $i$ 到 $j$ 上面留下的信息素量为 $0$。</p><p>​        一般来说有了信息素浓度的更新公式，就可以直接给出蚂蚁对每条路径的选择概率了。然而，为了更好的利用TSP问题自身的性质，M.Dorigo等引入了一个启发项：$\eta=\frac{1}{d_{ij}}$ 。通过结合信息素浓度和启发因子，可以得到蚂蚁选择路径 $i$ 到 $j$ 的概率为：<br>$$<br>p_{ij}^{k}(t)=\left{\begin{array}{rcl}\frac{[\tau_{ij}(t)]^\alpha·[\eta_{ij}]^{\beta}}{\sum_{k= \in allowed : [\tau_{ik}(t)]^\alpha·[\eta_{ik}]^{\beta} } }, &amp;&amp; {j \in allowed_k}\ 0,       &amp;  &amp; {else}\end{array} \right.<br>$$</p><p>式中，$\alpha$ 和 $\beta$ 是调节因子，用于调节 $\tau_{ij}(t)$ 和 $\eta_{ij}$ 之间的作用。此外 $allowed_k$ 表示蚂蚁 $k$ 还没有走过的路径（用禁忌表存储已经走过的路径），通过这种存储可以保证所有解的逻辑可行。如果路径 $i$ 到 $j$ 上的信息浓度越大 $\tau_{ij}(t)$ 的值就越大，该路径被选择的概率就越大；同样，如果该路径长度越短，则 $\eta=\frac{1}{d_{ij}}$ 越大，该路径被选择的概率也越大。</p><p>&nbsp;</p><p><strong>求解TSP问题的蚁群算法中的人工蚂蚁具有以下特点：</strong></p><p>1）他们概率性地选择下一条路径，该概率与<strong>路径长度</strong>和路径上的<strong>信息素浓度</strong>有关；</p><p>2）为了保证解的逻辑可行，蚂蚁不允许选择已经走过的路径（通过禁忌表实现）；</p><p>3）蚂蚁走过一条路径时会在该路径上面分泌一种叫做信息素的物质。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#==========================================</span></span><br><span class="line"><span class="comment">#对称矩阵，计算任意两个城市之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance_p2p_mat</span>():</span></span><br><span class="line">    dis_mat=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_city):</span><br><span class="line">        dis_mat_each=[]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_city):</span><br><span class="line">            dis=math.sqrt(<span class="built_in">pow</span>(location[i][<span class="number">0</span>]-location[j][<span class="number">0</span>],<span class="number">2</span>)+<span class="built_in">pow</span>(location[i][<span class="number">1</span>]-location[j][<span class="number">1</span>],<span class="number">2</span>))</span><br><span class="line">            dis_mat_each.append(dis)</span><br><span class="line">        dis_mat.append(dis_mat_each)</span><br><span class="line">   <span class="comment"># print(dis_mat)</span></span><br><span class="line">    <span class="keyword">return</span> dis_mat</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算所有寻找到的路径对应的距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_newpath</span>(<span class="params">dis_mat,path_new</span>):</span></span><br><span class="line">    dis_list=[]</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> path_new:</span><br><span class="line">        dis=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_city-<span class="number">1</span>):</span><br><span class="line">            dis=dis_mat[each[j]][each[j+<span class="number">1</span>]]+dis</span><br><span class="line">        dis=dis_mat[each[num_city-<span class="number">1</span>]][each[<span class="number">0</span>]]+dis<span class="comment">#回家</span></span><br><span class="line">        dis_list.append(dis)</span><br><span class="line">    <span class="keyword">return</span> dis_list</span><br><span class="line"><span class="comment">#==========================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location=np.loadtxt(<span class="string">&#x27;./city_location.txt&#x27;</span>)</span><br><span class="line">num_ant=<span class="number">200</span> <span class="comment">#蚂蚁个数</span></span><br><span class="line">num_city=<span class="number">30</span> <span class="comment">#城市个数</span></span><br><span class="line"></span><br><span class="line">alpha=<span class="number">1</span> <span class="comment">#信息素影响因子</span></span><br><span class="line">beta=<span class="number">5</span>  <span class="comment">#期望影响因子</span></span><br><span class="line">info=<span class="number">0.1</span> <span class="comment">#信息素的挥发率</span></span><br><span class="line">Q=<span class="number">1</span> <span class="comment">#常数</span></span><br><span class="line"></span><br><span class="line">count_iter = <span class="number">0</span>  <span class="comment">#迭代计数器</span></span><br><span class="line">iter_max = <span class="number">30</span>   <span class="comment">#迭代次数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dis_list=distance_p2p_mat()     <span class="comment">#计算任意两个城市间的距离</span></span><br><span class="line">dis_mat=np.array(dis_list)      <span class="comment">#将list转化为矩阵</span></span><br><span class="line"></span><br><span class="line">e_mat_init=<span class="number">1.0</span>/(dis_mat+np.diag([<span class="number">10000</span>]*num_city))      <span class="comment">#期望矩阵。加对角阵是原矩阵对角线为0，而除数不能是0，所以先用一个比较大的数垫一下</span></span><br><span class="line">diag=np.diag([<span class="number">1.0</span>/<span class="number">10000</span>]*num_city)          <span class="comment">#上一步生成的num_city*num_city维的对角线为1000的对角矩阵</span></span><br><span class="line">e_mat=e_mat_init-diag           <span class="comment">#已经做过除法了，所以让对角线元素复原，再减去那个对角矩阵</span></span><br><span class="line"></span><br><span class="line">pheromone_mat=np.ones((num_city,num_city))    <span class="comment">#信息浓度矩阵。初始化每条边的信息素浓度，全1矩阵</span></span><br><span class="line"></span><br><span class="line">path_mat=np.zeros((num_ant,num_city)).astype(<span class="built_in">int</span>)     <span class="comment">#蚂蚁的路径矩阵。初始化每只蚂蚁路径，都从0城市出发.(如果不加数据转化，则默认生成的是float类型的0，即0.0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> count_iter &lt; iter_max:    <span class="comment">#最外层迭代</span></span><br><span class="line">    <span class="keyword">for</span> ant <span class="keyword">in</span> <span class="built_in">range</span>(num_ant):  <span class="comment">#对每一只蚂蚁进行分析</span></span><br><span class="line">        visit=<span class="number">0</span>     <span class="comment">#都从0城市出发</span></span><br><span class="line">        unvisit_list=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">30</span>))  <span class="comment">#未访问的城市。这个语句生成一个[1..29]的数组。再加上统一的出发点0，共30个城市</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,num_city):  <span class="comment">#j代表第ant个蚂蚁的第j步</span></span><br><span class="line">            </span><br><span class="line">            trans_list=[]</span><br><span class="line">          </span><br><span class="line">            trans=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(unvisit_list)):  <span class="comment">#第ant个蚂蚁的第j步取哪个城市</span></span><br><span class="line">                trans +=np.power(pheromone_mat[visit][unvisit_list[k]],alpha)*np.power(e_mat[visit][unvisit_list[k]],beta)  <span class="comment">#计算第ant个蚂蚁由visit位置向k位置走的概率。这里要注意：直接累加</span></span><br><span class="line">                trans_list.append(trans)      <span class="comment">#将 每一步 累加的结果保存到一个数组中</span></span><br><span class="line">             </span><br><span class="line">            <span class="comment">#轮盘法选择下一个城市</span></span><br><span class="line">            rand=random.uniform(<span class="number">0</span>,trans)<span class="comment">#产生随机数</span></span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(trans_list)):</span><br><span class="line">                <span class="keyword">if</span>(rand &lt;= trans_list[t]):  <span class="comment">#因为之前就已经累加了，trans_list[t]一定是一个递增数组，所以可以直接与trans_list[t]相比较</span></span><br><span class="line">                    visit_next=unvisit_list[t]  <span class="comment">#选择下标为t的城市作为这个蚂蚁下一步的方向</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">      </span><br><span class="line">            path_mat[ant,j]=visit_next  <span class="comment">#装填这只蚂蚁的路径矩阵</span></span><br><span class="line"></span><br><span class="line">            unvisit_list.remove(visit_next) <span class="comment">#在未走的城市列表中删去这个结点。这个操作，就会使unvisit_list这个数组变成断断续续的</span></span><br><span class="line">            visit=visit_next    <span class="comment">#更新这只蚂蚁的当前位置</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">#所有蚂蚁的路径表填满之后，算每只蚂蚁的总距离</span></span><br><span class="line">    dis_allant_list=cal_newpath(dis_mat,path_mat)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#选取拥有最短路径的蚂蚁的路径</span></span><br><span class="line">    <span class="comment"># 注意：这里其实可以不用写成if-else结构，但那样对于每一次迭代都需要一次min和max计算，而有时候后一次迭代结果并不一定比前一次迭代结果更优，就会造成冗余计算。</span></span><br><span class="line">    <span class="comment">#       使用if-else结构后，每一次迭代只是一个判断，并不需要每次都进行min和max计算</span></span><br><span class="line">    <span class="keyword">if</span> count_iter == <span class="number">0</span>:</span><br><span class="line">        dis_new=<span class="built_in">min</span>(dis_allant_list)</span><br><span class="line">        path_new=path_mat[dis_allant_list.index(dis_new)].copy()      </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">min</span>(dis_allant_list) &lt; dis_new:</span><br><span class="line">            dis_new=<span class="built_in">min</span>(dis_allant_list)</span><br><span class="line">            path_new=path_mat[dis_allant_list.index(dis_new)].copy() </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为了避免残留信息素过多而淹没启发式信息，所以要及时的更新信息素矩阵</span></span><br><span class="line">    pheromone_change=np.zeros((num_city,num_city))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_ant):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_city-<span class="number">1</span>):</span><br><span class="line">            pheromone_change[path_mat[i,j]][path_mat[i,j+<span class="number">1</span>]] += Q/dis_mat[path_mat[i,j]][path_mat[i,j+<span class="number">1</span>]]</span><br><span class="line">        pheromone_change[path_mat[i,num_city-<span class="number">1</span>]][path_mat[i,<span class="number">0</span>]] += Q/dis_mat[path_mat[i,num_city-<span class="number">1</span>]][path_mat[i,<span class="number">0</span>]] <span class="comment">#最后一个结点到起点</span></span><br><span class="line">    </span><br><span class="line">    pheromone_mat=(<span class="number">1</span>-info)*pheromone_mat + pheromone_change</span><br><span class="line"></span><br><span class="line">    count_iter += <span class="number">1</span> <span class="comment">#迭代计数+1，进入下一次迭代</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">print(<span class="string">&#x27;最短距离：&#x27;</span>,dis_new)</span><br><span class="line">print(<span class="string">&#x27;最短路径：&#x27;</span>,path_new)</span><br></pre></td></tr></table></figure><p><code>city_location.txt</code>内容表示城市的横纵坐标，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">41 94</span><br><span class="line">37 84</span><br><span class="line">54 67</span><br><span class="line">25 62</span><br><span class="line">7 64</span><br><span class="line">2 99</span><br><span class="line">68 58</span><br><span class="line">71 44</span><br><span class="line">54 62</span><br><span class="line">83 69</span><br><span class="line">64 60</span><br><span class="line">18 54</span><br><span class="line">22 60</span><br><span class="line">83 46</span><br><span class="line">91 38</span><br><span class="line">25 38</span><br><span class="line">24 42</span><br><span class="line">58 69</span><br><span class="line">71 71</span><br><span class="line">74 78</span><br><span class="line">87 76</span><br><span class="line">18 40</span><br><span class="line">13 40</span><br><span class="line">82 7</span><br><span class="line">62 32</span><br><span class="line">58 35</span><br><span class="line">45 21</span><br><span class="line">41 26</span><br><span class="line">44 35</span><br><span class="line">4 50</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h2 id="三、运行结果"><a href="#三、运行结果" class="headerlink" title="三、运行结果"></a>三、运行结果</h2><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/08/04/aBNOvF.png"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;​        蚁群算法（Ant Colony Algorithm）最初于1992年由意大利学者M.Dorigo等人提出，它是一种模拟自然界中真实蚁群觅食行为的仿生优化算法。研究发现：每只蚂蚁觅食时在走过的路线上会留下一种称为信息素的物质，蚂蚁之间靠感知这种物质的浓度进行信息传递。蚂蚁在选择路径时总是倾向于朝信息索浓度高的方向移动，而距离短的路径上走过的蚂蚁多，留下的信息素也多，后续蚂蚁选择它的概率也会越大；其他路径上的信息素会随着时间的推移不断挥发，这样就形成了一种正反馈机制，最后整个蚁群聚集到最短路径上。&lt;/p&gt;
&lt;p&gt;​        人工蚁群算法模拟了这一过程。每只蚂蚁在解空间独立地搜索可行解，解越好留下的信息素越多，随着算法推进，较优解路径上的信息素增多，选择它的蚂蚁也随之增多，最终收敛到最优或近似最优的解上。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://hansy.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="元启发式搜索算法" scheme="https://hansy.tech/tags/%E5%85%83%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>遗传算法</title>
    <link href="https://hansy.tech/2020/08/2633671626.html"/>
    <id>https://hansy.tech/2020/08/2633671626.html</id>
    <published>2020-08-04T06:47:15.000Z</published>
    <updated>2020-08-04T06:47:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>遗传算法 (Genetic Algorithm, GA) 是由 John Holland 提出，其学生 Goldberg 对整个算法进行了进一步完善。算法的整个思想来源于达尔文的进化论，其基本思想是根据问题的目标函数构造一个适应度函数 (Fitness Function)，对于种群中的每个个体 (即问题的一个解) 进行评估 (计算适应度)，选择，交叉和变异，通过多轮的繁殖选择适应度最好的个体作为问题的最优解。算法的整个流程如下所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://d33wubrfki0l68.cloudfront.net/eedd66c9f9a47dec6aa3b97406bc47053e7ab678/ee942/images/cn/2019-04-05-heuristic-algorithms/ga-process.png" alt="GA-Process"></p><a id="more"></a><p>&nbsp;</p><p>&nbsp;</p><h2 id="一、初始化种群"><a href="#一、初始化种群" class="headerlink" title="一、初始化种群"></a>一、初始化种群</h2><p>在初始化种群时，我们首先需要对每一个个体进行编码，常用的编码方式有二进制编码，实值编码等。以二进制为例，对于 $p∈{0,1,…,100}$ 中 $p_i=50$ 可以表示为：<br>$$<br>x_i=50_{10}=0110010_2<br>$$<br>对于一个具体的问题，我们需要选择合适的编码方式对问题的解进行编码，编码后的个体可以称之为一个染色体。则一个染色体可以表示为：<br>$$<br>x=(p_1,p_2,…,p_m)<br>$$<br>其中，$m$ 为染色体的长度或编码的位数。初始化种群个体共 $n$ 个，对于任意一个个体染色体的任意一位 $i$，随机生成一个随机数 $rand∈U(0,1)$ ，若 $rand&gt;0.5$ ，则 $p_i=1$ ，否则 $p_i=0$。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="二、计算适应度"><a href="#二、计算适应度" class="headerlink" title="二、计算适应度"></a>二、计算适应度</h2><p>适应度为评价个体优劣程度的函数 $f(x)$ ，通常为问题的目标函数，对最小化优化问题 $f(x)=−min∑L(\hat{y},y)$ ，对最大化优化问题  $f(x)=max∑L(\hat{y},y)$ ，其中 $L$ 为损失函数。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="三、选择"><a href="#三、选择" class="headerlink" title="三、选择"></a>三、选择</h2><p>对于种群中的每个个体，计算其适应度，记第 i 个个体的适应度为  $F_i=f(x_i)$ 。则个体在一次选择中被选中的概率为：<br>$$<br>P_i = \dfrac{F_i}{\sum_{i=1}^{n}{F_i}}<br>$$<br>为了保证种群的数量不变，我们需要重复 n 次选择过程，单次选择采用轮盘赌的方法。利用计算得到的被选中的概率计算每个个体的累积概率：<br>$$<br>CP_0=0 \<br>CP_i=\sum_{j=1}^iP_i<br>$$</p><p>对于如下一个示例：</p><table><thead><tr><th>指标 \ 个体</th><th>x1</th><th>x2</th><th>x3</th><th>x4</th><th>x5</th><th>x6</th></tr></thead><tbody><tr><td>适应度 (F)</td><td>100</td><td>60</td><td>60</td><td>40</td><td>30</td><td>20</td></tr><tr><td>概率 (P)</td><td>0.322</td><td>0.194</td><td>0.194</td><td>0.129</td><td>0.097</td><td>0.064</td></tr><tr><td>累积概率 (CP)</td><td>0.322</td><td>0.516</td><td>0.71</td><td>0.839</td><td>0.936</td><td>1</td></tr></tbody></table><p>每次选择时，随机生成 $rand∈U(0,1)$，当 $CP_{i−1}≤rand≤CP_i$ 时，选择个体 $x_i$。选择的过程如同在下图的轮盘上安装一个指针并随机旋转，每次指针停止的位置的即为选择的个体。</p><p><img src= "/img/loading.gif" data-lazy-src="https://d33wubrfki0l68.cloudfront.net/2a0f423e15b3b2f3acba1e81815f35f1ca26dde8/7b543/images/cn/2019-04-05-heuristic-algorithms/ga-roulette-wheel.png" alt="GA-Roulette-Wheel"></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="四、交叉"><a href="#四、交叉" class="headerlink" title="四、交叉"></a>四、交叉</h2><p>交叉运算类似于染色体之间的交叉，常用的方法有单点交叉，多点交叉和均匀交叉等。</p><ul><li>单点交叉：在染色体中选择一个切点，然后将其中一部分同另一个染色体的对应部分进行交换得到两个新的个体。交叉过程如下图所示：</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://d33wubrfki0l68.cloudfront.net/8d200e6c615cb83a635aaaff56c43b2531658dc1/f9f46/images/cn/2019-04-05-heuristic-algorithms/ga-crossover-one-point.png"></p><ul><li>多点交叉：在染色体中选择多个切点，对其任意两个切点之间部分以概率 $P_c$ 进行交换，其中 $P_c$ 为一个较大的值，例如  $P_m=0.9$ 。两点交叉过程如下图所示：</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://d33wubrfki0l68.cloudfront.net/82dff98f294780db9abd9f0da4ccf7ab78845234/8a1b0/images/cn/2019-04-05-heuristic-algorithms/ga-crossover-two-points.png"></p><ul><li>均匀交叉：染色体任意对应的位置以一定的概率进行交换得到新的个体。交叉过程如下图所示：</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://d33wubrfki0l68.cloudfront.net/be3600cd728b467447a02ffb693a7f185c453a29/cb43f/images/cn/2019-04-05-heuristic-algorithms/ga-crossover-uniform.png"></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="五、变异"><a href="#五、变异" class="headerlink" title="五、变异"></a>五、变异</h2><p>变异即对于一个染色体的任意位置的值以一定的概率 $P_m$ 发生变化，对于二进制编码来说即反转该位置的值。其中 $P_m$ 为一个较小的值，例如 $P_m=0.05$。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在整个遗传运算的过程中，不同的操作发挥着不同的作用：</p><ol><li>选择：优胜劣汰，适者生存。</li><li>交叉：丰富种群，持续优化。</li><li>变异：随机扰动，避免局部最优。</li></ol><p>&nbsp;</p><p>&nbsp;</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#这两行代码让输出的图形中显示中文</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] =<span class="literal">False</span> <span class="comment">#减号unicode编码</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initCities</span>(<span class="params">firstCity</span>):</span></span><br><span class="line">    cities = []</span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    file=<span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)   <span class="comment">#读取文件</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">        line = line.replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot; &quot;</span>)  <span class="comment">#替换换行符</span></span><br><span class="line">        <span class="comment">#print(line)</span></span><br><span class="line">        line = line.split(<span class="string">&quot;,&quot;</span>)         <span class="comment">#按逗号分隔</span></span><br><span class="line">        <span class="comment">#print(line)</span></span><br><span class="line">        cities.append([n,<span class="built_in">float</span>(line[<span class="number">1</span>]),<span class="built_in">float</span>(line[<span class="number">2</span>]),line[<span class="number">0</span>]] )  <span class="comment">#组装。集合中的每一个元组，第一个元素为城市编号（从0开始），第二三个元素为城市坐标，第四个元素为城市名字</span></span><br><span class="line">        <span class="comment">#print(cities)</span></span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">0</span>] == firstCity:       <span class="comment">#判断当前城市是否为输入的城市。如果是，则将这个元组和集合的第一个元组互换位置下标，以将他放在旅行的起点</span></span><br><span class="line">            cities[<span class="number">0</span>][<span class="number">0</span>]=n</span><br><span class="line">            cities[n][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        n+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    cities = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">sorted</span>(cities)]   <span class="comment">#经过位置互换后，cities集合中的编号序列不再有序，经过排序后才能真正地将输入的城市放在集合首位</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> cities    <span class="comment">#返回城市列表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#求出给定个体（基因链条）（路径数组）的首元素绕一圈回到首元素所需要的路径长度   </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance</span>(<span class="params">order</span>):</span></span><br><span class="line">    distance = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(order)-<span class="number">1</span>):   <span class="comment">#对每一组相邻的地点求距离，然后累加</span></span><br><span class="line">        num1, num2 = order[i], order[i + <span class="number">1</span>]</span><br><span class="line">        distance += city_distance[num1][num2]</span><br><span class="line">    distance+=city_distance[num2][<span class="number">0</span>]        <span class="comment">#添加从最后一个城市回到原点的距离</span></span><br><span class="line">    <span class="keyword">return</span> distance         <span class="comment">#返回整圈的距离</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将距离插入到lives中的首元素位置</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inserted</span>(<span class="params">i</span>):</span></span><br><span class="line">    i.insert(<span class="number">0</span>,distance(i))     </span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#交叉，将所选取的两个个体交叉，也就是一次性交换多个城市的位置</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross</span>(<span class="params">par1,par2</span>):</span></span><br><span class="line">    par1.pop(<span class="number">0</span>)     <span class="comment">#弹出首元素（此路径总长度）</span></span><br><span class="line">    par2.pop(<span class="number">0</span>)     <span class="comment">#弹出首元素（此路径总长度）</span></span><br><span class="line"></span><br><span class="line">    num1 = random.randint(<span class="number">2</span>,<span class="built_in">len</span>(par1)-<span class="number">1</span>)  <span class="comment">#选取交叉的起点</span></span><br><span class="line">    num2 = random.randint(num1,<span class="built_in">len</span>(par2)-<span class="number">1</span>)     <span class="comment">#选取交叉的终点</span></span><br><span class="line">    crossGene = par2[num1:num2]     <span class="comment">#执行交叉的片段</span></span><br><span class="line">    <span class="comment">#判断现在所处的位置</span></span><br><span class="line">    flag = <span class="number">0</span> </span><br><span class="line">    Gene = []</span><br><span class="line">    <span class="keyword">for</span> life <span class="keyword">in</span> par1:</span><br><span class="line">        <span class="keyword">if</span> flag == num1:        <span class="comment">#到交叉的起点时，则直接添加片段crossGene到子代中。这个if语句只会执行一次</span></span><br><span class="line">            Gene.extend(crossGene)</span><br><span class="line">            flag += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> life <span class="keyword">not</span> <span class="keyword">in</span> crossGene:   <span class="comment">#如果当前元素不属于片段crossGene，则把它加到子代中。这个if语句会执行【个体基因长度（路径长度）-len(crossGene)】次</span></span><br><span class="line">            Gene.append(life)</span><br><span class="line">            flag += <span class="number">1</span></span><br><span class="line">    Gene=inserted(Gene)     <span class="comment">#添加首元素（此路径总长度）</span></span><br><span class="line">    <span class="keyword">return</span> Gene     <span class="comment">#返回下一代的基于（路径信息）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#变异，随机交换两个城市之间的位置</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mutation</span>(<span class="params">Gene</span>):</span></span><br><span class="line">    gene=Gene.copy()</span><br><span class="line">    num=gene.pop(<span class="number">0</span>)     <span class="comment">#弹出首元素（此路径总长度）</span></span><br><span class="line">    <span class="comment">#随机产生两个被交换的地点，并交换位置</span></span><br><span class="line">    num1 = random.randint(<span class="number">1</span>, <span class="built_in">len</span>(gene)-<span class="number">1</span>)</span><br><span class="line">    num2 = random.randint(<span class="number">1</span>, <span class="built_in">len</span>(gene)-<span class="number">1</span>)</span><br><span class="line">    gene[num1],gene[num2] = gene[num2],gene[num1]       <span class="comment">#交换动作</span></span><br><span class="line">    gene=inserted(gene)     <span class="comment">#添加首元素（此路径总长度）</span></span><br><span class="line">    <span class="keyword">if</span> gene[<span class="number">0</span>]&lt;Gene[<span class="number">0</span>]:     <span class="comment">#判断变异的效果。如果距离还没有之前短，则使这次变异无效；如果变异后距离变短了，则使这次变异生效</span></span><br><span class="line">        <span class="keyword">return</span> gene</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Gene</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#物竞天择，弱者死亡</span></span><br><span class="line"><span class="comment">#设置强者的定义概率，即种群前30%为强者</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dellist</span>(<span class="params">lives</span>):</span></span><br><span class="line">    retain_rate=<span class="number">0.3</span>     <span class="comment">#前30%的个体绝对不会被淘汰</span></span><br><span class="line">    num=<span class="built_in">int</span>(retain_rate*<span class="built_in">len</span>(lives))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num,<span class="built_in">len</span>(lives)-<span class="number">1</span>):   <span class="comment">#在后70%的个体中随机淘汰三分之二的个体</span></span><br><span class="line">        flag=random.randrange(<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> flag&lt;<span class="number">2</span>:       <span class="comment">#因为flag的取值范围是[0,2]，有66.7%的可能性满足这个条件，以此达到三分之二概率的淘汰</span></span><br><span class="line">            <span class="keyword">del</span> lives[num-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> lives</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#自然选择算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nature</span>(<span class="params">lives</span>):</span></span><br><span class="line">    var_time=<span class="number">0</span>  <span class="comment">#变异次数</span></span><br><span class="line">    cro_time=<span class="number">0</span>  <span class="comment">#交叉次数（也就是一共产生多少次子代） </span></span><br><span class="line">    newlives1=[]</span><br><span class="line">    newlives2=lives[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    breaktime=<span class="number">0</span></span><br><span class="line">    <span class="comment">#一共遗传1500次，越大效果越好</span></span><br><span class="line">    <span class="keyword">for</span> time <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1500</span>):</span><br><span class="line">        <span class="keyword">if</span> time == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> lives:</span><br><span class="line">                <span class="keyword">if</span> i != <span class="literal">None</span>:</span><br><span class="line">                    newlives1.append(inserted(i))   <span class="comment">#插入距离</span></span><br><span class="line">        lives=[]</span><br><span class="line">        newlives1=[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">sorted</span>(newlives1)]    <span class="comment">#对newlives1按首元素（路径总长度）排序，使得newlives1[0][0]为这一代的最优路径的总长度</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">#ewlives2[0]初始时为lives[0][0]，一定是0，所以第一次if语句肯定不符合，会转到else中重新赋值，赋值一个上一次的最优路径。第二次判断if语句时，如果和第二次的最优路径一致，则说明出现了一次来连续的最优解</span></span><br><span class="line">        <span class="keyword">if</span> newlives1[<span class="number">0</span>][<span class="number">0</span>]==newlives2[<span class="number">0</span>]:   <span class="comment">#说明两次得到的最优解一致，成为一个连续相同的最优解。</span></span><br><span class="line">            breaktime += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            breaktime = <span class="number">0</span>       <span class="comment">#连续的最优解个数归零</span></span><br><span class="line">            newlives2=newlives1[<span class="number">0</span>]      <span class="comment">#给newlives2赋值一个上一次的最优解（最短路径序列）。这个地方很关键，最开始的时候就纳闷为什么newlives2的值不是0了？</span></span><br><span class="line">        <span class="keyword">if</span> breaktime &gt; <span class="number">100</span> &amp; time &gt;= <span class="number">500</span>:   <span class="comment">#当已经遗传到了500代之后并且有100个连续相同的最优解产生的时候进行break，说明进化的很好，不需要再进行淘汰、交叉、变异</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">#进行淘汰</span></span><br><span class="line">        newlives1=dellist(newlives1)  </span><br><span class="line"></span><br><span class="line">        num=count-<span class="built_in">len</span>(newlives1)</span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#在newlives1中随机选取两个个体进行交叉，最优的不进行</span></span><br><span class="line">            a=random.randrange(<span class="number">1</span>,<span class="built_in">len</span>(newlives1),<span class="number">1</span>)  <span class="comment">#随机选择两个个体</span></span><br><span class="line">            b=random.randrange(<span class="number">1</span>,<span class="built_in">len</span>(newlives1),<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> a!=b :</span><br><span class="line">                par1=newlives1[a].copy()    <span class="comment">#备份一下</span></span><br><span class="line">                par2=newlives1[b].copy()    <span class="comment">#备份一下</span></span><br><span class="line">                life=cross(par1,par2)   <span class="comment">#交叉</span></span><br><span class="line">                cro_time += <span class="number">1</span>       <span class="comment">#交叉次数加一</span></span><br><span class="line">                <span class="comment">#对交叉生成的子代进行变异(0.2的概率)</span></span><br><span class="line">                flag=random.randrange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> flag&lt;=<span class="number">1</span>:     <span class="comment">#因为flag的取值范围是[0,9]，只有20%的可能性满足这个条件，以此达到0.2的概率变异</span></span><br><span class="line">                    newlives1.append(mutation(life))        <span class="comment">#变异后再回到种群</span></span><br><span class="line">                    var_time+=<span class="number">1</span>     <span class="comment">#变异次数加一</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    newlives1.append(life)      <span class="comment">#比较幸运，免于变异，重新回到种群中生存</span></span><br><span class="line">            num-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;遗传次数：&quot;</span>+<span class="built_in">str</span>(time+<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">&quot;交叉次数：&quot;</span>+<span class="built_in">str</span>(cro_time))</span><br><span class="line">    print(<span class="string">&quot;变异次数：&quot;</span>+<span class="built_in">str</span>(var_time))</span><br><span class="line">    <span class="keyword">return</span> newlives1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#firstCity=input(&quot;请输入出发城市： &quot;)</span></span><br><span class="line">firstCity=<span class="string">&#x27;南京&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取城市信息，并计算相互间的距离</span></span><br><span class="line">cities=initCities(firstCity)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">geneLength=<span class="built_in">len</span>(cities)</span><br><span class="line"><span class="comment">#生成距离矩阵city_distance，方便调用</span></span><br><span class="line">city_distance=np.zeros([geneLength,geneLength])     <span class="comment">#置零，初始化</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(geneLength):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(geneLength):</span><br><span class="line">        city_distance[i][j]=math.sqrt((cities[i][<span class="number">1</span>] - cities[j][<span class="number">1</span>]) ** <span class="number">2</span> +(cities[i][<span class="number">2</span>] - cities[j][<span class="number">2</span>]) ** <span class="number">2</span>)  <span class="comment">#因为是用直角坐标系表示的城市的位置，所以直接使用两点距离公式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#刚开始时生成300个个体（种群数量为300）。放到大自然中</span></span><br><span class="line">count=<span class="number">300</span></span><br><span class="line">lives=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">    aGene = [ x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,geneLength) ]   <span class="comment">#此时的aGene为一个从1到33的升序的数组，代表该个体的基因链条</span></span><br><span class="line">    random.shuffle(aGene)   <span class="comment">#将数组打乱。这个乱序，就有可能就是将来的旅行路径，当然，中间会经过进化变异</span></span><br><span class="line">    aGene.insert(<span class="number">0</span>,<span class="number">0</span>)       <span class="comment">#在数组的第一个位置插入0，表示开始的位置。此时基因的长度为34，即城市的数量</span></span><br><span class="line">    lives.append(aGene)     <span class="comment">#将该个体的基因保存到基因库中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算算法运行时间</span></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="comment">#执行繁衍进程</span></span><br><span class="line">lives=nature(lives)  <span class="comment">#返回的这个lives此时是一个大矩阵，每一行的第2到最后的元素为一条个体的基因链条（即候选的城市游览路线），第1个元素为该路径的长度。     并且第1个元素按列有序，即第一行为最佳路径，长度为最短长度</span></span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;运行时间：&quot;</span>+<span class="built_in">str</span>(end-start)+<span class="string">&quot;s&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;最优路径：&quot;</span>+<span class="built_in">str</span>(lives[<span class="number">0</span>][<span class="number">1</span>:]))</span><br><span class="line">print(<span class="string">&quot;最短距离：&quot;</span>+<span class="built_in">str</span>(lives[<span class="number">0</span>][<span class="number">0</span>]))    <span class="comment">#lives[0][0]代表最优路径的长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将cities按照lives下标的顺序排列。</span></span><br><span class="line"><span class="built_in">list</span>=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lives[<span class="number">0</span>][<span class="number">1</span>:]:    <span class="comment">#lives[0][1:]代表进化完后，适应性最强的那个个体的基因链条（即最优的城市游览路线） ；  lives[0][0]代表最优路径的长度</span></span><br><span class="line">    <span class="built_in">list</span>.append(cities[i])  <span class="comment">#按照得到的下标，将城市加入到结果list中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;\n遍历顺序为：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    print(i[<span class="number">3</span>],end=<span class="string">&#x27; &#x27;</span>)     <span class="comment">#第四个元素才为城市的名字，所以为i[3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">p1=[]</span><br><span class="line">p2=[]</span><br><span class="line">p3=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    p1.append(i[<span class="number">1</span>])     <span class="comment">#横坐标</span></span><br><span class="line">    p2.append(i[<span class="number">2</span>])     <span class="comment">#纵坐标</span></span><br><span class="line">    p3.append(i[<span class="number">3</span>])     <span class="comment">#城市名字</span></span><br><span class="line">p1.append(<span class="built_in">list</span>[<span class="number">0</span>][<span class="number">1</span>])       <span class="comment">#回到出发的城市，形成闭环</span></span><br><span class="line">p2.append(<span class="built_in">list</span>[<span class="number">0</span>][<span class="number">2</span>])       <span class="comment">#回到出发的城市，形成闭环</span></span><br><span class="line">plt.title(<span class="string">&#x27;以&#x27;</span>+firstCity+<span class="string">&#x27;为起始点的最短路线图&#x27;</span>)</span><br><span class="line">plt.plot(p1,p2)  <span class="comment"># plot绘制折线图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p1)-<span class="number">1</span>):    </span><br><span class="line">    plt.text(p1[i],p2[i],p3[i])     <span class="comment">#在指定的横纵坐标上标注城市名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示绘图</span></span><br><span class="line">plt.draw()  </span><br><span class="line"><span class="comment">#保存图象</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;GA_Final.png&#x27;</span>)</span><br><span class="line">plt.close() </span><br></pre></td></tr></table></figure><p><code>data.txt</code>文件内容为中国的34个城市的地理坐标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">北京,116.46,39.92</span><br><span class="line">天津,117.2,39.13</span><br><span class="line">上海,121.48,31.22</span><br><span class="line">重庆,106.54,29.59</span><br><span class="line">拉萨,91.11,29.97</span><br><span class="line">乌鲁木齐,87.68,43.77</span><br><span class="line">银川,106.27,38.47</span><br><span class="line">呼和浩特,111.65,40.82</span><br><span class="line">南宁,108.33,22.84</span><br><span class="line">哈尔滨,126.63,45.75</span><br><span class="line">长春,125.35,43.88</span><br><span class="line">沈阳,123.38,41.8</span><br><span class="line">石家庄,114.48,38.03</span><br><span class="line">太原,112.53,37.87</span><br><span class="line">西宁,101.74,36.56</span><br><span class="line">济南,117,36.65</span><br><span class="line">郑州,113.6,34.76</span><br><span class="line">南京,118.78,32.04</span><br><span class="line">合肥,117.27,31.86</span><br><span class="line">杭州,120.19,30.26</span><br><span class="line">福州,119.3,26.08</span><br><span class="line">南昌,115.89,28.68</span><br><span class="line">长沙,113,28.21</span><br><span class="line">武汉,114.31,30.52</span><br><span class="line">广州,113.23,23.16</span><br><span class="line">台北,121.5,25.05</span><br><span class="line">海口,110.35,20.02</span><br><span class="line">兰州,103.73,36.03</span><br><span class="line">西安,108.95,34.27</span><br><span class="line">成都,104.06,30.67</span><br><span class="line">贵阳,106.71,26.57</span><br><span class="line">昆明,102.73,25.04</span><br><span class="line">香港,114.1,22.2</span><br><span class="line">澳门,113.33,22.13</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>程序设定出发点为<code>南京</code>，当然，可以自定义。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/08/04/a0Ddts.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/08/04/a0ql6K.png"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;遗传算法 (Genetic Algorithm, GA) 是由 John Holland 提出，其学生 Goldberg 对整个算法进行了进一步完善。算法的整个思想来源于达尔文的进化论，其基本思想是根据问题的目标函数构造一个适应度函数 (Fitness Function)，对于种群中的每个个体 (即问题的一个解) 进行评估 (计算适应度)，选择，交叉和变异，通过多轮的繁殖选择适应度最好的个体作为问题的最优解。算法的整个流程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://d33wubrfki0l68.cloudfront.net/eedd66c9f9a47dec6aa3b97406bc47053e7ab678/ee942/images/cn/2019-04-05-heuristic-algorithms/ga-process.png&quot; alt=&quot;GA-Process&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://hansy.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="元启发式搜索算法" scheme="https://hansy.tech/tags/%E5%85%83%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>模拟退火算法</title>
    <link href="https://hansy.tech/2020/08/2698379703.html"/>
    <id>https://hansy.tech/2020/08/2698379703.html</id>
    <published>2020-08-03T10:47:53.000Z</published>
    <updated>2020-08-03T10:47:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>模拟退火算法来源于固体退火原理。</strong></p><p><strong>物理退火</strong>: 将材料加热后再经特定速率冷却，目的是增大晶粒的体积，并且减少晶格中的缺陷。材料中的原子原来会停留在使内能有局部最小值的位置，加热使能量变大，原子会离开原来位置，而随机在其他位置中移动。退火冷却时速度较慢，使得原子有较多可能可以找到内能比原先更低的位置。</p><p><strong>模拟退火</strong>: 其原理也和固体退火的原理近似。模拟退火算法从某一较高初温出发，伴随温度参数的不断下降,结合概率突跳特性在解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。</p><a id="more"></a><h2 id="爬山算法"><a href="#爬山算法" class="headerlink" title="爬山算法"></a>爬山算法</h2><p>爬山算法是一种简单的贪心搜索算法，该算法<strong>每次从当前解的临近解空间中选择一个最优解作为当前解，直到达到一个局部最优解</strong>。这种算法思想很单纯，但是也存在一个很大的缺陷。在搜索选择的过程中有可能会陷入局部最优解，<strong>而这个局部最优解不一定是全局最优解</strong>。比如下面这个问题：</p><p>​                                                     <img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202008/1534055-20200804182913901-1545346263.png" style="zoom:50%;" /></p><p>假设A是当前解，爬山算法往前继续搜索，当搜索到B这个局部最优解时就会停止搜索了。<strong>因为此时在B点无论是往哪边走都不会得到更优的解了</strong>。但是，全局最优解在C点。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h2><p>爬山法是完完全全的贪心法，这种贪心是很鼠目寸光的，只把眼光放在局部最优解上，因此只能搜索到局部的最优值。<strong>模拟退火其实也是一种贪心算法，只不过与爬山法不同的是，模拟退火算法在搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解</strong>。从上图来说，模拟退火算法在搜索到局部最优解B后，会以一定的概率接受向右的移动。也许经过几次这样的不是局部最优的移动后会到达BC之间的峰点D，这样一来便跳出了局部最优解B，继续往右移动就有可能获得全局最优解C。如下图：</p><p>​                                                    <img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202008/1534055-20200804182913901-1545346263.png" style="zoom:50%;" />    </p><p>对比上面两种算法，对于模拟退火算法我们提到了一个很important的概念–<code>一定的概率</code>，关于这个一定的概率是如何计算的。这里还是参考了固体的物理退火过程。</p><p>根据热力学的原理，在温度为T时，出现能量差为dE的降温的概率为P(dE)，表示为：<br>$$<br>P(dE)=e^{\frac{dE}{kT}}<br>$$</p><p>其中k是一个常数，exp表示自然指数，且dE&lt;0(温度总是降低的)。这条公式指明了：</p><ol><li>温度越高，出现一次能量差为dE的降温的概率就越大；</li><li>温度越低，则出现降温的概率就越小。<strong>又由于dE总是小于0（不然怎么叫退火），因此dE/kT &lt; 0 ，exp(dE/kT)取值是(0,1),那么P(dE)的函数取值范围是(0,1) 。</strong></li></ol><p>随着温度T的降低，P(dE)会逐渐降低。我们将一次向较差解的移动看做一次温度跳变过程，<strong>我们以概率P(dE)来接受这样的移动</strong>。也就是说，在用固体退火模拟组合优化问题，<strong>将内能E模拟为目标函数值 f，温度T演化成控制参数 t</strong>，即得到解组合优化问题的模拟退火演算法：由初始解 i 和控制参数初值 t 开始，对当前解重复“<strong>产生新解→计算目标函数差→接受或丢弃</strong>”的迭代，并逐步衰减 t 值，算法终止时的当前解即为所得近似最优解。</p><p>因此我们归结起来就是以下几点：</p><ol><li><strong>若f( Y(i+1) ) &lt;= f( Y(i) )</strong>  (即移动后得到更优解)，则总是接受该移动；</li><li><strong>若f( Y(i+1) ) &gt; f( Y(i) )</strong>  (即移动后的解比当前解要差)，则以一定的概率接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定）相当于上图中，<strong>从B移向BC之间的小波峰D时，每次右移(即接受一个更糟糕值)的概率在逐渐降低</strong>。如果这个坡特别长，那么很有可能最终我们并不会翻过这个坡。如果它不太长，<strong>这很有可能会翻过它</strong>，这取决于衰减 t 值的设定。</li></ol><p>&nbsp;</p><p>&nbsp;</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202008/1534055-20200803220946106-1945247794.png"></p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202008/1534055-20200804184237696-743957545.png" style="zoom:67%;" /><p>&nbsp;</p><p>&nbsp;</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">num_city=<span class="number">30</span><span class="comment">#城市总数</span></span><br><span class="line">initial_t=<span class="number">120</span><span class="comment">#初始温度</span></span><br><span class="line">lowest_t=<span class="number">0.001</span><span class="comment">#最低温度</span></span><br><span class="line">M=<span class="number">150</span><span class="comment">#当连续多次都不接受新的状态，开始改变温度</span></span><br><span class="line">iteration=<span class="number">300</span><span class="comment">#设置迭代次数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location=np.loadtxt(<span class="string">&#x27;./city_location.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#==========================================</span></span><br><span class="line"><span class="comment">#对称矩阵，两个城市之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance_p2p_mat</span>():</span></span><br><span class="line">    dis_mat=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">        dis_mat_each=[]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">            dis=math.sqrt(<span class="built_in">pow</span>(location[i][<span class="number">0</span>]-location[j][<span class="number">0</span>],<span class="number">2</span>)+<span class="built_in">pow</span>(location[i][<span class="number">1</span>]-location[j][<span class="number">1</span>],<span class="number">2</span>))</span><br><span class="line">            dis_mat_each.append(dis)</span><br><span class="line">        dis_mat.append(dis_mat_each)</span><br><span class="line">   <span class="comment"># print(dis_mat)</span></span><br><span class="line">    <span class="keyword">return</span> dis_mat</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算所有路径对应的距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_newpath</span>(<span class="params">dis_mat,path</span>):</span></span><br><span class="line">    dis=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_city-<span class="number">1</span>):</span><br><span class="line">        dis=dis_mat[path[j]][path[j+<span class="number">1</span>]]+dis</span><br><span class="line">    dis=dis_mat[path[<span class="number">29</span>]][path[<span class="number">0</span>]]+dis<span class="comment">#回家</span></span><br><span class="line">    <span class="keyword">return</span> dis</span><br><span class="line"></span><br><span class="line"><span class="comment">#==========================================</span></span><br><span class="line"><span class="comment">#点对点距离矩阵</span></span><br><span class="line">dis_mat=distance_p2p_mat()</span><br><span class="line"><span class="comment">#初始路径</span></span><br><span class="line">path=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">30</span>))</span><br><span class="line"><span class="comment">#初始距离</span></span><br><span class="line">dis=cal_newpath(dis_mat,path)</span><br><span class="line"><span class="comment">#初始温度</span></span><br><span class="line">t_current=initial_t</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (t_current&gt;lowest_t):<span class="comment">#外循环，改变温度</span></span><br><span class="line">    count_m=<span class="number">0</span><span class="comment">#M的计数</span></span><br><span class="line">    count_iter=<span class="number">0</span><span class="comment">#迭代次数计数</span></span><br><span class="line">    <span class="keyword">while</span> (count_m&lt;M <span class="keyword">and</span> count_iter&lt;iteration):<span class="comment">#内循环，连续多次不接受新的状态或者是迭代多次,跳出内循环        </span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(i==j):<span class="comment">#防止随机了同一城市</span></span><br><span class="line">            i=random.randint(<span class="number">1</span>,<span class="number">29</span>)</span><br><span class="line">            j=random.randint(<span class="number">1</span>,<span class="number">29</span>)</span><br><span class="line">        path_new=path.copy()</span><br><span class="line">        path_new[i],path_new[j]=path_new[j],path_new[i]<span class="comment">#任意交换两个城市的位置,产生新解</span></span><br><span class="line">        <span class="comment">#计算新解的距离</span></span><br><span class="line">        dis_new=cal_newpath(dis_mat,path_new)</span><br><span class="line">        <span class="comment">#求差</span></span><br><span class="line">        dis_delta=dis_new-dis</span><br><span class="line">        <span class="comment">#取0-1浮点随机数</span></span><br><span class="line">        rand=random.random()</span><br><span class="line">        <span class="comment">#计算指数函数的值</span></span><br><span class="line">        exp_d=math.exp(-dis_delta/t_current)</span><br><span class="line">        <span class="comment">#选择</span></span><br><span class="line">        <span class="keyword">if</span> dis_delta&lt;<span class="number">0</span>:</span><br><span class="line">            path=path_new</span><br><span class="line">            dis=dis_new</span><br><span class="line">        <span class="keyword">elif</span> exp_d&gt;rand:</span><br><span class="line">            path=path_new</span><br><span class="line">            dis=dis_new    </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count_m=count_m+<span class="number">1</span></span><br><span class="line">        count_iter=count_iter+<span class="number">1</span></span><br><span class="line">    t_current=<span class="number">0.99</span>*t_current<span class="comment">#改变温度</span></span><br><span class="line"><span class="comment">#外循环结束</span></span><br><span class="line">dis_min=dis</span><br><span class="line">path_min=path</span><br><span class="line">print(<span class="string">&#x27;最短距离：&#x27;</span>,dis_min)</span><br><span class="line">print(<span class="string">&#x27;最短路径：&#x27;</span>,path_min)</span><br></pre></td></tr></table></figure><p><code>city_location.txt</code>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">41 94</span><br><span class="line">37 84</span><br><span class="line">54 67</span><br><span class="line">25 62</span><br><span class="line">7 64</span><br><span class="line">2 99</span><br><span class="line">68 58</span><br><span class="line">71 44</span><br><span class="line">54 62</span><br><span class="line">83 69</span><br><span class="line">64 60</span><br><span class="line">18 54</span><br><span class="line">22 60</span><br><span class="line">83 46</span><br><span class="line">91 38</span><br><span class="line">25 38</span><br><span class="line">24 42</span><br><span class="line">58 69</span><br><span class="line">71 71</span><br><span class="line">74 78</span><br><span class="line">87 76</span><br><span class="line">18 40</span><br><span class="line">13 40</span><br><span class="line">82 7</span><br><span class="line">62 32</span><br><span class="line">58 35</span><br><span class="line">45 21</span><br><span class="line">41 26</span><br><span class="line">44 35</span><br><span class="line">4 50</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202008/1534055-20200803221553561-154411210.png"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;模拟退火算法来源于固体退火原理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;物理退火&lt;/strong&gt;: 将材料加热后再经特定速率冷却，目的是增大晶粒的体积，并且减少晶格中的缺陷。材料中的原子原来会停留在使内能有局部最小值的位置，加热使能量变大，原子会离开原来位置，而随机在其他位置中移动。退火冷却时速度较慢，使得原子有较多可能可以找到内能比原先更低的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模拟退火&lt;/strong&gt;: 其原理也和固体退火的原理近似。模拟退火算法从某一较高初温出发，伴随温度参数的不断下降,结合概率突跳特性在解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://hansy.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="元启发式搜索算法" scheme="https://hansy.tech/tags/%E5%85%83%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>粒子群算法</title>
    <link href="https://hansy.tech/2020/08/4262056254.html"/>
    <id>https://hansy.tech/2020/08/4262056254.html</id>
    <published>2020-08-03T10:23:09.000Z</published>
    <updated>2020-08-03T10:23:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>粒子群算法也称粒子群优化算法PSO（Particle Swarm Optimization），属于进化算法EA（Evolutionary Algorithm）的一种，实现容易、精度高、收敛快，是一种并行算法。它是从随机解出发，通过迭代寻找最优解，也是通过适应度来评价解的品质，它通过追随当前搜索到的最优值来寻找全局最优。</p><a id="more"></a><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>设x为粒子起始位置，v为粒子飞行速度，p为搜索到的粒子的最优位置。</p><p>PSO初始化为一群随机粒子，然后通过迭代找到最优解。在每一次迭代中，粒子通过跟踪两个极值来更新自己：第一个就是粒子本身所找到的最优解，这个解称为个体极值pbest；另一个极值是整个种群目前找到的最优解，这个极值是全局极值gbest。粒子始终跟随这两个极值并在每一次迭代中更新自己的位置和速度，直到找到最优解。</p><p>具体如下：</p><p>假设在一个D维的目标搜索空间中，有N个粒子组成一个群落，其中第i个粒子为一个D维向量：<br>$$<br>X_i=(x_{i_1},x_{i_2},…,x_{i_D}) \qquad i=1,2,…,N<br>$$</p><p>第i个粒子的飞行速度也是一个D维向量：<br>$$<br>V_i=(v_{i_1},v_{i_2},…,v_{i_D}) \qquad i=1,2,…,N<br>$$<br>第i个粒子迄今为止搜索到的最优位置，即个体极值Pbest：<br>$$<br>P_{best}=(p_{i_1},p_{i_2},…,p_{i_D}) \qquad i=1,2,…,N<br>$$</p><p>整个粒子群迄今为止搜索到的最优位置，即全局极值Gbest：<br>$$<br>G_{best}=(p_{g_1},p_{g_2},…,p_{g_D})<br>$$</p><p>在找到这两个最优值时，粒子根据如下公式来更新自己的速度和位置：<br>$$<br>v_{i_d}=w*v_{i_d}+c_1r_1(p_{i_d}-x_{i_d})+c_2r_2(p_{g_d}-x_{i_d}) \<br>x_{i_d}=x_{i_d}+v_{i_d}<br>$$<br>其中，c1、c2为学习因子，也称加速常数（acceleration constant）；r1、r2为[0,1]范围内的均匀随机数。<br>第一个公式右侧包括三部分，</p><ul><li>第1部分为惯性inertia或动量momentum，代表了粒子有维持自己先前速度的趋势；</li></ul><ul><li>第2部分为认知cognition，反映了粒子对自己历史经验的记忆或回忆，代表粒子有向自身历史最佳位置逼近的趋势；</li></ul><ul><li>第3部分为社会social，反映了粒子间协同合作与知识共享的群体历史经验，代表粒子有向群体或邻近历史最佳位置逼近的趋势。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ol><li>初始化粒子群，包括群体规模N、每个粒子的位置xi和速度vi计算每个粒子的适应度值Fit[i]</li><li>对每个粒子，用它的适应度值Fit[i]和个体极值pbest(i)比较，如果Fit[i]&gt;pbest(i)，则用Fit[i]替换掉   pbest(i)</li><li>对每个粒子，用其适应度Fit[i]和全局极值gbest(i)比较，如果Fit[i]&gt;gbest(i)，则用Fit[i]替换掉gbest(i)</li><li>根据公式更新粒子的位置xi和速度vi</li><li>如果满足结束条件，误差足够好或达到最大循环次数，退出，否则返回2</li></ol><p>&nbsp;</p><p>&nbsp;</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">******************************目标函数***********************************</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#  目标函数 ， 同时也将他设定为 适应度函数   （一维）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fitness</span>(<span class="params">x</span>):</span></span><br><span class="line">    y = -x**<span class="number">2</span> - <span class="number">8</span>*x -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> y </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">******************************初始化***********************************</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ************************初始化简单参数*************************************</span></span><br><span class="line">w = <span class="number">0.8</span>    <span class="comment">#惯性因子</span></span><br><span class="line">c1 = <span class="number">2</span>     <span class="comment">#自身认知因子</span></span><br><span class="line">c2 = <span class="number">2</span>     <span class="comment">#社会认知因子</span></span><br><span class="line">r1 = <span class="number">0.6</span>  <span class="comment">#自身认知学习率</span></span><br><span class="line">r2 = <span class="number">0.3</span>  <span class="comment">#社会认知学习率</span></span><br><span class="line">pN = <span class="number">100</span>             <span class="comment">#粒子数量</span></span><br><span class="line">dim = <span class="number">1</span>             <span class="comment">#搜索维度  </span></span><br><span class="line">max_iter = <span class="number">1000</span>    <span class="comment">#最大迭代次数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = np.zeros((pN, dim))       <span class="comment">#初始粒子的位置 </span></span><br><span class="line">V = np.zeros((pN, dim))       <span class="comment">#初始粒子的速度 </span></span><br><span class="line">p_best = np.zeros((pN, dim), dtype = <span class="built_in">float</span>)   <span class="comment">#单个粒子的历史最佳位置</span></span><br><span class="line">g_best = np.zeros((<span class="number">1</span>, dim), dtype = <span class="built_in">float</span>)    <span class="comment">#全局最佳位置  </span></span><br><span class="line">p_bestfit = np.zeros(pN)      <span class="comment">#单个粒子的历史最佳适应值  </span></span><br><span class="line">g_bestfit = -<span class="number">1e15</span>             <span class="comment">#全局最佳适应值  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># *********************初始化个体和全局的最优解********************************</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pN):  </span><br><span class="line">    <span class="comment">#初始化每一个粒子的位置和速度</span></span><br><span class="line">    X[i] = np.random.uniform(<span class="number">0</span>,<span class="number">5</span>,[<span class="number">1</span>, dim])  </span><br><span class="line">    V[i] = np.random.uniform(<span class="number">0</span>,<span class="number">5</span>,[<span class="number">1</span>, dim]) </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到初始时的每一个粒子的历史最佳位置（暂且将第一次给的值定为最佳位置）</span></span><br><span class="line">    p_best[i] = X[i] </span><br><span class="line">    p_bestfit[i] = get_fitness(X[i])  <span class="comment">#得到对应的fit值</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到初始时的全局最佳位置和相应的适应度值（每遍历一个粒子就更新一次）</span></span><br><span class="line">    <span class="comment"># （这里不直接用max函数求最大值是因为不一定下一个粒子比前一个粒子更优，从而导致冗余计算。下面的那个for循环同理）</span></span><br><span class="line">  </span><br><span class="line">g_bestfit = <span class="built_in">max</span>(p_bestfit)</span><br><span class="line">g_best = <span class="built_in">max</span>(p_best)  <span class="comment">#得到全局最佳位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">***************************迭代***********************************#</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">fitness = []  <span class="comment">#记录每次迭代的最优解，画图时用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iter):  </span><br><span class="line"></span><br><span class="line">    <span class="comment">#  更新每个粒子的位置和速度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pN):  </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 更新g_best 和 p_best  </span></span><br><span class="line">        temp = get_fitness(X[i])  <span class="comment">#获得当前位置的适应值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> temp &gt; p_bestfit[i]:      <span class="comment">#先更新个体最优  </span></span><br><span class="line">            p_bestfit[i] = temp  </span><br><span class="line">            p_best[i] = X[i]  </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> p_bestfit[i] &gt; g_bestfit:  <span class="comment">#再更新全局最优  （注意：这里不直接用max函数求最大值是因为最外面还有一层max_iter迭代循环，从而更容易导致冗余计算；而初始化时的那重循环外面再无循环层，所以即使使用max函数也不会造成什么冗余。）</span></span><br><span class="line">                g_best = X[i]  </span><br><span class="line">                g_bestfit = p_bestfit[i]  </span><br><span class="line"></span><br><span class="line">        V[i] = w*V[i] + c1*r1*(p_best[i] - X[i]) + c2*r2*(g_best - X[i])  </span><br><span class="line">        X[i] = X[i] + V[i] </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    #  这样写没错，可以代替上面的那层if语句，但不能这样写，因为最外面还有一重max_iter循环，如果下一次迭代不比当前最优解还好的话，就造成了max函数计算冗余</span></span><br><span class="line"><span class="string">    g_bestfit = max(p_bestfit)</span></span><br><span class="line"><span class="string">    g_best = max(p_best)  </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    fitness.append(g_bestfit)  <span class="comment"># 记录每次迭代后找到的全局最优解</span></span><br><span class="line">    </span><br><span class="line">print(g_best, g_bestfit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">***************************画图***********************************#</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Figure1&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;iterators&quot;</span>, size=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;fitness&quot;</span>, size=<span class="number">14</span>)</span><br><span class="line">t = np.array([t <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, max_iter)])</span><br><span class="line">fitness = np.array(fitness)</span><br><span class="line">plt.plot(t, fitness, color=<span class="string">&#x27;b&#x27;</span>, linewidth=<span class="number">3</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/08/03/aaHwdI.png"></p><p>很明显对于函数<code>y = -x**2 - 8*x -1</code>，当<code>x=-4</code>时取最大值<code>y=15</code></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;粒子群算法也称粒子群优化算法PSO（Particle Swarm Optimization），属于进化算法EA（Evolutionary Algorithm）的一种，实现容易、精度高、收敛快，是一种并行算法。它是从随机解出发，通过迭代寻找最优解，也是通过适应度来评价解的品质，它通过追随当前搜索到的最优值来寻找全局最优。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://hansy.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="元启发式搜索算法" scheme="https://hansy.tech/tags/%E5%85%83%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>YOLO v4学习总结</title>
    <link href="https://hansy.tech/2020/07/4258418483.html"/>
    <id>https://hansy.tech/2020/07/4258418483.html</id>
    <published>2020-07-20T03:49:04.000Z</published>
    <updated>2020-07-20T03:49:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class='spoiler collapsed'>    <div class='spoiler-title'>        原论文：《Optimal Speed and Accuracy of Object Detection》    </div>    <div class='spoiler-content'>        <p><strong>原论文</strong>：<a href="http://xxx.itp.ac.cn/abs/2004.10934">http://xxx.itp.ac.cn/abs/2004.10934</a></p><p><strong>下载好的</strong>：<a href="https://wwa.lanzous.com/iyURFf05ssb">https://wwa.lanzous.com/iyURFf05ssb</a></p>    </div></div><p>&nbsp;</p><p>&nbsp;</p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>想要继续学习yolo系列算法，就不得不提从v4开始其作者便已不再是 J.R 了。年初大神<a href="https://mp.weixin.qq.com/s?__biz=MzUxNjcxMjQxNg==&mid=2247496822&idx=2&sn=89fe4610a3993204c5c21058d9923c5d&chksm=f9a186f9ced60fefd543f86eaa05125b185560e0c6f27598575eaac5045c1b421b86b13421ea&scene=21#wechat_redirect">Joseph Redmon宣布推出CV界，坦言无法忽视自己工作带来的负面影响</a>（AI算法用于军事和隐私窥探），此事在工业界和学术界引起了轩然大波，正当大家担忧yolo算法是否会就此“停更”时，俄罗斯开发者 Alexey Bochkovskiy 和两位中国台湾开发者 Chien-Yao Wang、Hong-Yuan Mark Liao扛过大旗，在4月24日联手推出yolo v4，并且获得了Joseph Redmon的承认。</p><p>&nbsp;</p><p>相对于理论创新来说，YOLOv4 更多的是集成许许多多的trick并取得了不错的效果，打造实现了最佳速度与精度平衡的目标检测新基准。我现在的目标就是了解模型运行的流程，然后尽可能地去学习其中的核心trick。</p><p>由于自己水平太低，所以更需要从原论文本身开始学习，了解基本框架后再去寻找一些技术博客加深理解。本文结构参考原论文结构，分析译文并做出一些修改使自己更易于理解。     <font size=2>（just write for myself）</font></p><p>&nbsp;</p><p><font color=brone>译文来源：公众号【计算机视觉联盟】</font><br><font color=brone>主要参考：公众号【机器之心】、【Cver】、【GiantPandaCV】</font></p><p>可以看出，我整个yolo v4的学习都是基于公众号，这次学习过程除了让我又有了几个”置顶“的公众号外，我还加入几个关于计算机视觉的微信群，群里每天都有大佬发言，群助手会在朋友圈实时发布世界范围内高校或企业的高质量CV论文的相关信息，虽说现在一篇也看不懂，但也很开心，毕竟有那个味儿了！</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/27/aFbY6K.png"></p><p>&nbsp;</p><p>&nbsp;</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>许多特征可以提高 CNN 的准确率，然而真正实行起来还需要在大型数据集上对这些特征组合进行实际测试，并且对测试结果进行理论验证。某些特征仅在特定模型上运行，并且局限于特定的问题，或是只能在小型数据集上运行；而另外有些特征（如批归一化和残差连接）则适用于大多数模型、任务和数据集。</p><p>YOLOv4 使用了以下特征组合，实现了新的 SOTA 结果：</p><ul><li>加权残差连接（WRC）</li><li>Cross-Stage-Partial-connection，CSP</li><li>Cross mini-Batch Normalization，CmBN</li><li>自对抗训练（Self-adversarial-training，SAT）</li><li>Mish 激活（Mish-activation）</li><li>Mosaic 数据增强</li><li>DropBlock 正则化</li><li>CIoU 损失</li></ul><p>&nbsp;</p><p>据介绍，YOLOv4 在 MS COCO 数据集上获得了 43.5% 的 AP 值 (65.7% AP50)，在 Tesla V100 上实现了 ∼65 FPS 的实时速度。</p><p>作者对比了 YOLOv4 和当前最优目标检测器，发现 YOLOv4 在取得与 EfficientDet 同等性能的情况下，速度是 EfficientDet 的二倍！此外，与 YOLOv3 相比，新版本的 AP 和 FPS 分别提高了 10% 和 12%。</p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/27/aFb2nS.png" style="zoom:60%;" /><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>对于目标检测而言，高准确度早已不是唯一的目标。我们还希望边缘设备也能流畅地运行这些模型。因此，如何使用低成本硬件实时地处理输入视频也成为了一个重要的研究方向。我们的目标是任何人使用传统的单个GPU进行训练和测试，都可以获得实时、高质量和令人信服的目标检测结果。我们的贡献概括如下：</p><ol><li>建立了一个高效强大的目标检测模型。它使得每个人都可以使用 1080Ti 或 2080Ti 的 GPU 来训练一个快速准确的目标检测器。</li><li>验证了当前最优 Bag-of-Freebies 和 Bag-of-Specials 目标检测方法在检测器训练过程中的影响。</li><li>修改了 SOTA 方法，使之更加高效，更适合单 GPU 训练。这些方法包括 CBN、PAN、SAM 等。</li></ol><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="二、目标检测算法（Object-detection-models）"><a href="#二、目标检测算法（Object-detection-models）" class="headerlink" title="二、目标检测算法（Object detection models）"></a>二、目标检测算法（Object detection models）</h1><p>目标检测算法一般有两部分组成：一个是在ImageNet预训练的骨架（backbone），另一个是用来预测对象类别和边界框的头部。对于头部，通常分为两类，即一级对象检测器和二级对象检测器。</p><p>近年来发展起来的目标探测器经常在主干和头部之间插入一些层，这些层通常用来收集不同阶段的特征图。我们可以称它为物体探测器的颈部。通常，颈部由几个自下而上的路径和几个自上而下的路径组成。具有这种机制的网络包括特征金字塔网络(FPN)、路径聚集网络(PAN)、BiFPN和NAS-FPN。</p><p>&nbsp;</p><p>总而言之，普通的检测器由以下几个部分组成：</p><ul><li>输入：图像，斑块，图像金字塔</li><li>骨架：VGG16，ResNet-50，SpineNet ，EfficientNet-B0 / B7，CSPResNeXt50，CSPDarknet53</li><li>颈部：<ul><li>其他块：SPP，ASPP，RFB，SAM</li><li>路径聚合块：FPN，PAN，NAS-FPN，Fully-connected FPN，BiFPN，ASFF，SFAM</li></ul></li><li>Heads ：<ul><li>密集预测（一阶段）：<ul><li>RPN，SSD，YOLO， RetinaNet（基于锚）</li><li>CornerNet，CenterNet，MatrixNet，FCOS（无锚）</li></ul></li><li>稀疏预测（两阶段）：<ul><li>Faster R-CNN，R-FCN，Mask R-CNN（基于锚）</li><li>RepPoints（无锚）</li></ul></li></ul></li></ul><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/27/aFbJl6.png" style="zoom:60%;" /><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="三、YOLO-V4-方法（Methodology）"><a href="#三、YOLO-V4-方法（Methodology）" class="headerlink" title="三、YOLO V4 方法（Methodology）"></a>三、YOLO V4 方法（Methodology）</h1><p>该研究的主要目标是找出输入网络分辨率、卷积层数量、参数量（滤波器大小、滤波器通道/组）和层输入数量（滤波器）四者之间的最优平衡。次要目标则是挑选能够增加感受野的额外块（additional block），以及针对不同级别的检测器从不同骨干层中挑选最佳的参数聚合方法，如 FPN、PAN、ASFF 和 BiFPN 网络。</p><p>&nbsp;</p><h2 id="3-1-Selection-of-architecture"><a href="#3-1-Selection-of-architecture" class="headerlink" title="3.1 Selection of architecture"></a>3.1 Selection of architecture</h2><p>具体而言，YOLOv4 包含以下三部分：</p><ul><li>骨干网络：CSPDarknet53</li><li>Neck：SPP、PAN</li><li>Head：YOLOv3</li></ul><p>&nbsp;</p><p>相比于基于 ResNet 的设计，CSPDarknet53 模型的目标检测准确度更高，不过 ResNet 的分类性能更好一些。但是，借助后文将讨论的 Mish 和其它技术，CSPDarknet53 的分类准确度可以得到提升。</p><p>SPP 模块，因为它能够极大地增加感受野，分离出最显著的上下文特征，并且几乎没有降低网络运行速度。</p><p>针对不同级别的检测器从不同骨干层中挑选 PANet 作为参数聚合方法。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="3-2-Selection-of-BoF-and-BoS"><a href="#3-2-Selection-of-BoF-and-BoS" class="headerlink" title="3.2 Selection of BoF and BoS"></a>3.2 Selection of BoF and BoS</h2><p>为了提升准确度，可以针对训练过程进行一些优化，比如数据增强、类别不平衡、成本函数、软标注等等，这些改进不会影响推理速度，可被称为<code>「Bag of freebies」</code>。另外还有一些改进可称为<code>「bag of specials」</code>，仅需在推理时间方面做少许牺牲，就能获得优良的性能回报。这类改进包括增大感受野、使用注意力机制、集成跳过连接（skip-connection）或 FPN 等特性、使用非极大值抑制等后处理方法。本文将探讨骨架、头部、颈部的设计方式以及好用的 BoF 和 BoS 改进策略。</p><p>具体而言，YOLO v4 关于BoF 和 BoS和使用情况如下所述</p><h3 id="1-用于骨干部分的-Bag-of-freebies"><a href="#1-用于骨干部分的-Bag-of-freebies" class="headerlink" title="1. 用于骨干部分的 Bag of freebies"></a>1. 用于骨干部分的 Bag of freebies</h3><ul><li>CutMix 和 Mosaic 数据增强</li><li>DropBlock 正则化</li><li>类别标签平滑化</li></ul><p>&nbsp;</p><h3 id="2-用于骨干部分的-Bag-of-Specials"><a href="#2-用于骨干部分的-Bag-of-Specials" class="headerlink" title="2. 用于骨干部分的 Bag of Specials"></a>2. 用于骨干部分的 Bag of Specials</h3><ul><li>Mish 激活</li><li>交叉阶段部分连接（CSP)</li><li>多输入加权的残差连接（MiWRC）</li></ul><p>&nbsp;</p><h3 id="3-用于检测器的-Bag-of-freebies"><a href="#3-用于检测器的-Bag-of-freebies" class="headerlink" title="3. 用于检测器的 Bag of freebies"></a>3. 用于检测器的 Bag of freebies</h3><ul><li>CIoU-loss</li><li>CmBN</li><li>DropBlock 正则化</li><li>Mosaic 数据增强</li><li>自对抗训练</li><li>消除网格敏感度</li><li>针对一个真值使用多个锚</li><li>余弦退火调度器</li><li>使用遗传算法求最优超参数</li><li>随机训练形状</li></ul><p>&nbsp;</p><h3 id="4-用于检测器的-Bag-of-Specials"><a href="#4-用于检测器的-Bag-of-Specials" class="headerlink" title="4. 用于检测器的 Bag of Specials"></a>4. 用于检测器的 Bag of Specials</h3><ul><li>Mish 激活</li><li>修改版 SPP 模块</li><li>修改版 SAM 模块</li><li>修改版 PAN 路径聚合模块</li><li>DIoU-NMS</li></ul><p>&nbsp;</p><p>&nbsp;</p><h2 id="3-3-Additional-improvements"><a href="#3-3-Additional-improvements" class="headerlink" title="3.3 Additional improvements"></a>3.3 Additional improvements</h2><p>为了使检测器更适合在单个 GPU 上进行训练，研究者还做出了以下额外的设计与改进：</p><ul><li>提出新型数据增强方法 Mosaic 和自对抗训练（SAT）</li><li>在应用遗传算法时选择最优超参数</li><li>修改现有方法，使新方法实现高效训练和检测——modified SAM、modified PAN 和 Cross mini-Batch Normalization (CmBN)</li></ul><p>&nbsp;</p><h3 id="1-Mosaic数据增强方法"><a href="#1-Mosaic数据增强方法" class="headerlink" title="1. Mosaic数据增强方法"></a>1. Mosaic数据增强方法</h3><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202007/1534055-20200727231418746-1914398146.png" style="zoom:40%;" /><p>这个方法是将4张不同的图片镶嵌到一张图中，其优点是：</p><ul><li>混合四张具有不同语义信息的图片，可以让检测器检测超出常规语境的目标，增强模型的鲁棒性。</li><li>由于BN是从四张图片计算得到的，所以可以减少对大的mini-batch的依赖。</li></ul><p>&nbsp;</p><h3 id="2-Self-Adversarial-Training"><a href="#2-Self-Adversarial-Training" class="headerlink" title="2. Self-Adversarial Training"></a>2. Self-Adversarial Training</h3><p>自对抗训练也是一种新的数据增强方法，可以一定程度上抵抗对抗攻击。其包括两个阶段，每个阶段进行一次前向传播和一次反向传播。</p><ul><li>第一阶段，CNN通过反向传播改变图片信息，而不是改变网络权值。通过这种方式，CNN可以进行对抗性攻击，改变原始图像，造成图像上没有目标的假象。</li><li>第二阶段，对修改后的图像进行正常的目标检测。</li></ul><p>&nbsp;</p><h3 id="3-CmBN"><a href="#3-CmBN" class="headerlink" title="3. CmBN"></a>3. CmBN</h3><p>CmBN 是 CBN 的改进版，它仅收集单个批次内 mini-batch 之间的统计数据。</p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202007/1534055-20200727224722778-778034819.png" style="zoom:45%;" /><p>上图表达的是三种不同的BN方式，理解的时候应该从左往右看，BN是对当前mini-batch进行归一化。CBN是对当前以及当前往前数3个mini-batch的结果进行归一化。而本文提出的CmBN则是仅仅在这个Batch中进行累积。</p><p>&nbsp;</p><h3 id="4-modified-SAM"><a href="#4-modified-SAM" class="headerlink" title="4. modified SAM"></a>4. modified SAM</h3><p>注意力已经在深度学习设计中得到了广泛的应用。SAM 会为输入特征图分别应用最大池化和平均池化，从而得到两个特征图集合。其结果会被送入一个卷积层，之后再由一个 sigmoid 函数创建出空间注意力。</p><p>​                   <img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202007/1534055-20200727224727105-1523051895.png" style="zoom:60%;" /></p><p>这个空间注意力掩码再被应用于输入特征，从而输出经过优化的特征图。</p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202007/1534055-20200727224751040-1557992066.png" style="zoom:50%;" /><p>YOLOv4 使用了一种修改版的 SAM，其中没有使用最大池化和平均池化，还将 SAM 从空间注意力机制（spatial-wise attention）修改为点注意力机制（point-wise attention）如下图 5、6 所示：</p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202007/1534055-20200727224749636-1584618757.png" style="zoom:48%;" /><p>modified SAM中没有使用pooling, 而是直接用一个卷积得到的特征图直接使用Sigmoid进行激活, 然后对应点相乘, 所以说改进后的模型是Point-wise Attention.</p><p>&nbsp;</p><h3 id="5-modified-PANet"><a href="#5-modified-PANet" class="headerlink" title="5. modified PANet"></a>5. modified PANet</h3><p>早期的深度学习的模型设计相对简单。每一层的输入都来自其上一层。更前面的层会提取局部的纹理和图案信息，并构建出后续层所需的语义信息。但是，随着网络向右侧推进，微调优化预测结果时所需的局部信息可能会丢失。</p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202007/1534055-20200727224747822-1356389215.png" style="zoom:58%;" /><p>在后来的深度学习开发中，层之间的互连方式变得更加复杂。DenseNet 在这方面达到了极致。其中每一层都连接了其前面的所有层。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/han-suyu/cdn_others/A%20dense%20block%20with%205%20layers%20and%20growth%20rate%204.jpg"  style="zoom:10%;" /><p>在 FPN 中，来自自底向上和自上而下数据流的邻近层的信息会结合到一起。</p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202007/1534055-20200727224743481-1047478228.png" style="zoom:58%;" /><p>层之间信息的流动方式变成了模型设计中需要考虑的又一关键事项。</p><p>下图是用于目标检测的路径聚合网络（PAN）。其中，自底向上的路径得到增强，使得低层信息更容易传播到顶部。在 FPN 中，局部空间信息会向上传播，如红色箭头所示。尽管图中可能没有展示清楚，但这条红色路径穿过了大约 100 多层。PAN 引入了一个捷径路径（绿色路径），其仅需 10 层左右就能抵达顶部的 N₅ 层。这个短回路概念使得顶层也能获取到细粒度的局部信息。</p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202007/1534055-20200727224737921-562581725.png" style="zoom:58%;" /><p>但是，YOLOv4 并没有将邻近层加到一起，而是将特征图连接到一起。</p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202007/1534055-20200727224732196-853923805.png" style="zoom:45%;" /><p>&nbsp;</p><h3 id="6-使用遗传算法的超参数选择"><a href="#6-使用遗传算法的超参数选择" class="headerlink" title="6. 使用遗传算法的超参数选择"></a>6. 使用遗传算法的超参数选择</h3><p>进化算法是一种有根据的猜测方法。其遵循「适者生存」的概念。举个例子，如果我们随机选择 100 组超参数。然后使用它们训练 100 个模型。之后，我们从中选出表现最好的 10 个模型。对于每个被选中的模型，都根据原始版本创建 10 个超参数略有不同的变体版本。再使用这些新的超参数重新训练模型，再次选出其中表现最好的。随着我们不断迭代，我们应该可以找到超参数的最佳集合。另外，我们也可以一开始使用默认超参数，然后再执行突变。正如其论文（arXiv: 2004.10934）中写道：</p><blockquote><p>遗传算法使用 YOLOv3-SPP，根据 GIoU 损失进行训练，并为 min-val 5k 数据集搜索 300 epoch。我们为遗传算法实验采用了搜索得到的学习率 0.00261、动量 0.949、用于分配基本真值的 IoU 阈值 0.213 以及损失归一化算子 0.07。</p></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h1><p>与其他最先进的物体探测器获得的结果比较如图8所示。YOLOv4在速度和准确性方面均优于最快，为最准确的探测器。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/27/aFb66f.png"></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h1><p>总体来说，yolo v4的内容非常繁杂，涉及到非常非常多的trick，文章提到的Bag of freebies和Bag of specials需要好好整理，系统学习一下。最后放一张参考网上然后自己画出来的更详细的思维导图，留以  后用。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/27/aFbUmD.png"></p><p>&nbsp;</p><p>&nbsp;</p><blockquote><p>参考<br><a href="https://arxiv.org/pdf/2004.10934.pdf">https://arxiv.org/pdf/2004.10934.pdf</a><br><a href="https://my.oschina.net/u/4410124/blog/4334685">https://my.oschina.net/u/4410124/blog/4334685</a><br><a href="https://mp.weixin.qq.com/s/Ia1ZhAeTgt8anXVd4qxE3A">https://mp.weixin.qq.com/s/Ia1ZhAeTgt8anXVd4qxE3A</a><br><a href="https://mp.weixin.qq.com/s/XEPhK81Ms-wdDnoz5oPZgA">https://mp.weixin.qq.com/s/XEPhK81Ms-wdDnoz5oPZgA</a><br><a href="https://mp.weixin.qq.com/s/azMLqnqySOqugW941dS1HQ">https://mp.weixin.qq.com/s/azMLqnqySOqugW941dS1HQ</a></p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://hansy.tech/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="目标检测" scheme="https://hansy.tech/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    
    <category term="目标检测" scheme="https://hansy.tech/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    <category term="YOLO" scheme="https://hansy.tech/tags/YOLO/"/>
    
  </entry>
  
  <entry>
    <title>YOLO v3学习总结</title>
    <link href="https://hansy.tech/2020/07/2158053739.html"/>
    <id>https://hansy.tech/2020/07/2158053739.html</id>
    <published>2020-07-16T03:49:04.000Z</published>
    <updated>2020-07-16T03:49:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class='spoiler collapsed'>    <div class='spoiler-title'>        原论文：《An Incremental Improvement》    </div>    <div class='spoiler-content'>        <p><strong>原论文</strong>：<a href="https://arxiv.org/abs/1804.02767">https://arxiv.org/abs/1804.02767</a></p><p><strong>下载好的</strong>：<a href="https://wwa.lanzous.com/imidUerlbjc">https://wwa.lanzous.com/imidUerlbjc</a></p>    </div></div><p>&nbsp;</p><p>&nbsp;</p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>yolo v3虽说只是之前版本技术与其他经典网络模型优点的结合体，并没有更多新内容，但总体结构还是很复杂的，在学习yolo v3时，如果心中没有一个清晰的结构图，那理解起来绝对很困难（自己深有体会），而作者只在v1的论文里给出了结构图，v2和v3中都没有给出，并且v3的论文相对于v1 v2来说篇幅更短、有用信息更少，这也一定程度上增加了学习的难度。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="一、网络结构"><a href="#一、网络结构" class="headerlink" title="一、网络结构"></a>一、网络结构</h1><h2 id="1-1-backbone：Darknet-53"><a href="#1-1-backbone：Darknet-53" class="headerlink" title="1.1 backbone：Darknet-53"></a>1.1 backbone：Darknet-53</h2><p>backbone部分由Yolov2时期的Darknet-19进化至Darknet-53，加深了网络层数，引入了Resnet中的跨层加和操作。Darknet-19和Darknet-53的网络结构对比见图1。</p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/21/UTlcee.png" alt="图1：darknet-19与darknet-53的架构区别" style="zoom:50%;" /><p>从图1可以看出，darknet-19是不存在残差结构的，和VGG是同类型的backbone。几种经典网络的性能对比见图2</p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/21/UTlyLD.png" alt="图2：Darknet精度性能对比" style="zoom:60%;" /><p>从上表可以看出，Darknet-53处理速度每秒78张图，比Darknet-19慢不少，但是比同精度的ResNet快很多。yolo_v3其实并没有刻意追求速度，而是在保证实时性(fps&gt;36)的基础上追求精度。不过如果你要想更快，可以用一行代码切换到tiny-darknet。搭载tiny-darknet的yolo可以达到state of the art级别，甚至可以与squeezeNet相匹敌，详情可以看图3：<br>                                                    <img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdn.net/20180912155142706?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xldmlvcGt1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图3：Tiny-Darknet精度性能对比" style="zoom:67%;" /><br>所以，有了yolo v3，就真的用不着yolo v2了，更用不着yolo v1了。这也是<a href="https://pjreddie.com/darknet/">yolo官方网站</a>，在v3出来以后，就没提供v1和v2代码下载链接的原因了。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="1-2-详细框架"><a href="#1-2-详细框架" class="headerlink" title="1.2 详细框架"></a>1.2 详细框架</h2><p>先奉上总体结构图，来自知乎博主Algernon的文章【<a href="https://zhuanlan.zhihu.com/p/76802514">Yolo三部曲解读——Yolov3</a>】</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/21/UT18fI.jpg" alt="图4：YOLOv3数据流程图(1)"><br>&nbsp;</p><p>在Yolov3中只有卷积层，不存在池化层和全连接层。通过<strong>调节卷积步长控制输出特征图的尺寸</strong>。所以对于输入图片尺寸没有特别限制。</p><p>上面流程图中，输入样例图片的大小为256x256。总共输出3个特征图，细节如下：</p><ol><li><p><strong>过程</strong>：输入图像经过Darknet-53（无全连接层），再经过Yoloblock(512)生成特征图被当作两用，第一用经过3x3卷积层、1x1卷积层之后生成特征图一；第二用经过1x1卷积层加上采样层，与Darnet-53网络的中间层输出结果进行拼接，经过Yoloblock(256)后再被当作两用，第一用经过3x3卷积层、1x1卷积层之后生成特征图二；第二用经过1x1卷积层加上采样层，与Darnet-53网络的另一中间层输出结果进行拼接，经过Yoloblock(128)后再经过3x3卷积层、1x1卷积层生成特征图三。</p><blockquote><p>SSD直接采用backbone中间层的处理结果作为feature map的输出</p><p>YOLO v3将中间层的处理结果和后面网络层的上采样结果做一个拼接作为feature map的输出</p></blockquote></li><li><p><strong>尺寸</strong>：特征图的输出维度为 $N<em>N</em>[3*(4+1+80)]$ ，$N*N$ 为输出特征图格点数，一共3个Anchor框，每个框有4维预测数值 $t_x,t_y,t_w,t_h$ ，1维预测框置信度，80维预测物体类别。所以第一层特征图的输出维度为 8x8x255。因为第二层、第三层各加入了一次上采样，所以输出维度分别为16x16x255、32x32x255</p></li><li><p><strong>效果</strong>：从输入到输出，第一个特征图下采样32倍，第二个特征图下采样16倍，第三个下采样8倍。</p></li><li><p><strong>目的</strong>：Yolov3借鉴了<code>金字塔特征图</code>思想，使用不同大小的特征图去检测物体，<font color=red>小尺寸特征图用于检测大尺寸物体，而大尺寸特征图检测小尺寸物体。</font></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上采样(upsample)：是将小尺寸特征图通过插值等方法，生成大尺寸图像。例如使用最近邻插值算法，将8x8的图像变换为16x16。上采样层不改变特征图的通道数。</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p><strong>Yolo的整个网络，吸取了Resnet、Densenet、FPN的精髓，可以说是融合了目标检测当前业界最有效的全部技巧。</strong></p><p>&nbsp;</p><p>上图4是以输出结果为结点，以动作为连线，信息多且杂，下面给出一个以动作为结点的<a href="https://blog.csdn.net/leviopku/article/details/82660381">流程图</a>，可能看起来会更直观吧。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/21/UT13tA.jpg" alt="图5：YOLOv3数据流程图(2)"></p><p>对图5做一些补充解释：</p><ul><li><p><strong>DBL</strong>: 就是卷积+BN+Leaky relu。对于v3来说，BN和leaky relu已经是和卷积层不可分离的部分了(最后一层卷积除外)，共同构成了最小组件。</p></li><li><p><strong>Res unit</strong>：借鉴Resnet网络中的残差结构，让网络可以构建的更深。</p></li><li><p><strong>resn</strong>：n代表数字，有res1，res2, … ,res8等等，表示这个res_block里含有多少个res_unit。这是yolo_v3的大组件，yolo_v3开始借鉴了ResNet的残差结构，使用这种结构可以让网络结构更深。对于res_block的解释，可以在图1的右下角直观看到，其基本组件也是DBL。</p></li></ul><p>&nbsp;</p><p>其他基础操作：</p><p><strong>concat</strong>：张量拼接。将darknet中间层和后面的某一层的上采样进行拼接。拼接的操作和残差层add的操作是不一样的，加和操作来源于ResNet，将输入的特征图，与输出特征图对应维度进行相加，即 $y=f(x)+x$ ；而concat操作源于DenseNet，将特征图按照通道维度直接进行拼接，例如8x8x16的特征图与8x8x32的特征图拼接后生成8x8x48的特征图。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="二、Yolo输出特征图解码（前向过程）"><a href="#二、Yolo输出特征图解码（前向过程）" class="headerlink" title="二、Yolo输出特征图解码（前向过程）"></a>二、Yolo输出特征图解码（前向过程）</h1><p>yolo v3输出了3个不同尺度的feature map，这也是v3论文中提到的改进点：predictions across scales。这个借鉴了<strong>FPN</strong>，采用上采样的方法来实现这种多尺度的feature map，对不同size的目标进行检测，越精细的grid cell就可以检测出越精细的物体。</p><p>在Yolov3的设计中，每个特征图的每个格子中，都配置3个不同的先验框，所以最后三个特征图，这里暂且reshape为13 × 13 × 3 × 85、26 × 26 × 3 × 85、52 × 52 × 3 × 85，这样更容易理解，在代码中也是reshape成这样之后更容易操作。如图6所示。</p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/24/UvFVOS.png" alt="图6：映射细节" style="zoom:40%;" /><p>三张特征图就是整个Yolo输出的检测结果，检测框位置（4维）、检测置信度（1维）、类别（80维）都在其中，加起来正好是85维。特征图最后的维度85，代表的就是这些信息，而特征图其他维度N × N × 3，N × N代表了检测框的参考位置信息，3是3个不同尺度的先验框。下面详细描述怎么将检测信息解码出来（类似于v2）：</p><ul><li><p>先验框</p><p>在Yolov1中，网络直接回归检测框的宽、高，这样效果有限。所以在Yolov2中，改为了回归基于先验框的变化值，这样网络的学习难度降低，整体精度提升不小。Yolov3沿用了Yolov2中关于先验框的技巧，并且使用k-means对数据集中的标签框进行聚类，得到类别中心点的9个框，作为先验框。9个anchor会被三个输出张量平分的。根据大中小三种size各自取自己的anchor。另外，作者使用了logistic回归来对每个anchor包围的内容进行了一个目标性评分(objectness score)。 根据目标性评分来选择anchor prior进行predict，而不是所有anchor prior都会有输出。</p><p><code>注：先验框只与检测框的w、h有关，与x、y无关。</code></p></li></ul><p>&nbsp;</p><ul><li><p>检测框解码</p><p>有了先验框与输出特征图，就可以解码检测框 x，y，w，h。</p></li></ul><p>$$<br>b_x=\sigma(t_x)+c_x\<br>b_y=\sigma(t_y)+c_y\<br>b_w=p_we^{(t_w)}\<br>b_h=p_he^{(t_h)}\<br>$$</p><p>​        如图7所示，$\sigma(t_x),\sigma(t_y)$  是基于矩形框中心点左上角格点坐标的偏移量， $\sigma$ 是<strong>激活函数</strong>，论文中作者使用        sigmoid。$p_w,p_h$  是先验框的宽、高，通过上述公式，计算出实际预测框的宽高 $(b_w,b_h)$ 。</p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/12/U85Yzn.png" alt="图7：检测框解码" style="zoom:45%;" /><p>​        举个具体的例子，假设对于第二个特征图16 × 16 × 3 × 85中的第[5，4，2]维，上图中的 $c_y$ 为5， $c_x$ 为4，第          二个特征图对应的先验框为(30×61)，(62×45)，(59× 119)，prior_box的index为2，那么取最后一个59，119            作为先验w、先验h。这样计算之后的 $b_x,b_y$ 还需要乘以特征图二的采样率16，得到真实的检测框x,y。</p><p>&nbsp;</p><ul><li><p>检测置信度解码</p><p>物体的检测置信度，在Yolo设计中非常重要，关系到算法的检测正确率与召回率。置信度在输出85维中占固定一位，由sigmoid函数解码即可，解码之后数值区间在[0，1]中。</p></li></ul><p>&nbsp;</p><ul><li><p>类别解码</p><p>COCO数据集有80个类别，所以类别数在85维输出中占了80维，每一维独立代表一个类别的置信度。使用sigmoid激活函数替代了Yolov2中的softmax，取消了类别之间的互斥，可以使网络更加灵活。</p></li></ul><p>&nbsp;</p><p>三个特征图一共可以解码出 8 × 8 × 3 + 16 × 16 × 3 + 32 × 32 × 3 = 4032 个box以及相应的类别、置信度。这4032个box，在训练和推理时，使用方法不一样：</p><ol><li>训练时4032个box全部送入打标签函数，进行后一步的标签以及损失函数的计算。</li><li>推理时，选取一个置信度阈值，过滤掉低阈值box，再经过nms（非极大值抑制），就可以输出整个网络的预测结果了。</li></ol><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="三、训练策略与损失函数（反向过程）"><a href="#三、训练策略与损失函数（反向过程）" class="headerlink" title="三、训练策略与损失函数（反向过程）"></a>三、训练策略与损失函数（反向过程）</h1><h2 id="3-1-训练策略"><a href="#3-1-训练策略" class="headerlink" title="3.1 训练策略"></a>3.1 训练策略</h2><p>Yolov3论文中给出的训练策略</p><blockquote><p>YOLOv3 predicts an objectness score for each bounding box using logistic regression. This should be 1 if the bounding box prior overlaps a ground truth object by more than any other bounding box prior. If the bounding box prior is not the best but does overlap a ground truth object by more than some threshold we ignore the prediction, following [17]. We use the threshold of .5. Unlike [17] our system only assigns one bounding box prior for each ground truth object. If a bounding box prior is not assigned to a ground truth object it incurs no loss for coordinate or class predictions, only objectness.</p></blockquote><p>总结如下：</p><ol><li>预测框一共分为三种情况：正例（positive）、负例（negative）、忽略样例（ignore）。</li><li>正例：任取一个ground truth，与4032个框全部计算IOU，IOU最大的预测框，即为正例。并且一个预测框，只能分配给一个ground truth。例如第一个ground truth已经匹配了一个正例检测框，那么下一个ground truth，就在余下的4031个检测框中，寻找IOU最大的检测框作为正例。ground truth的先后顺序可忽略。正例产生置信度loss、检测框loss、类别loss。预测框为对应的ground truth box标签（需要反向编码，使用真实的x、y、w、h计算出  $t_x,t_y,t_w,t_h$ ；类别标签对应类别为1，其余为0；置信度标签为1。</li><li>忽略样例：正例除外，与任意一个ground truth的IOU大于阈值（论文中使用0.5），则为忽略样例。忽略样例不产生任何loss。</li><li>负例：正例除外（与ground truth计算后IOU最大的检测框，但是IOU小于阈值，仍为正例），与全部ground truth的IOU都小于阈值（0.5），则为负例。负例只有置信度产生loss，置信度标签为0。</li></ol><p>&nbsp;</p><p><font color=blue>训练策略的一些疑难点：</font></p><ul><li><p>ground truth为什么不按照中心点分配对应的预测box？</p><p>在Yolov3的训练策略中，不再像Yolov1那样，每个cell负责中心落在该cell中的ground truth。原因是Yolov3一共产生3个特征图，3个特征图上的cell，中心是有重合的。训练时，可能最契合的是特征图1的第3个box，但是推理的时候特征图2的第1个box置信度最高。所以Yolov3的训练，不再按照ground truth中心点，严格分配指定cell，而是根据预测值寻找IOU最大的预测框作为正例。</p></li><li><p>Yolov1中的置信度标签，就是预测框与真实框的IOU，Yolov3为什么是1？</p><p>置信度意味着该预测框是或者不是一个真实物体，是一个二分类，所以标签是1、0更加合理。</p></li><li><p>为什么有忽略样例？</p><p>忽略样例是Yolov3中的点睛之笔。由于Yolov3使用了多尺度特征图，不同尺度的特征图之间会有重合检测部分。比如有一个真实物体，在训练时被分配到的检测框是特征图1的第三个box，IOU达0.98，此时恰好特征图2的第一个box与该ground truth的IOU达0.95，也检测到了该ground truth，如果此时给其置信度强行打0的标签，网络学习效果会不理想。</p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h2 id="3-2-Loss函数"><a href="#3-2-Loss函数" class="headerlink" title="3.2 Loss函数"></a>3.2 Loss函数</h2><p>图1的Yolov3的损失函数抽象表达式如下：</p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/21/UTlWFA.png"  style="zoom:50%;"/><p>Yolov3 Loss为三个特征图Loss之和：<br>$$<br>Loss =loss_{N_1}+loss_{N_2}+loss_{N_3}<br>$$</p><ul><li> $\lambda$ 为权重常数，控制检测框Loss、obj置信度Loss、noobj置信度Loss之间的比例，通常负例的个数是正例的几十倍以上，可以通过权重超参控制检测效果。</li><li> $1_{ij}^{obj}$ 若是正例则输出1，否则为0；   $1_{ij}^{noobj}$ 若是负例则输出1，否则为0；忽略样例都输出0。</li><li>x、y、w、h使用MSE作为损失函数，也可以使用smooth L1 loss（出自Faster R-CNN）作为损失函数。smooth L1可以使训练更加平滑。置信度、类别标签由于是0，1二分类，所以使用<strong>二值交叉熵</strong>作为损失函数。</li></ul><p>&nbsp;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">xy_loss = object_mask * box_loss_scale * K.binary_crossentropy(raw_true_xy, raw_pred[..., <span class="number">0</span>:<span class="number">2</span>],</span><br><span class="line">                                                                       from_logits=<span class="literal">True</span>)</span><br><span class="line">wh_loss = object_mask * box_loss_scale * <span class="number">0.5</span> * K.square(raw_true_wh - raw_pred[..., <span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">confidence_loss = object_mask * K.binary_crossentropy(object_mask, raw_pred[..., <span class="number">4</span>:<span class="number">5</span>], from_logits=<span class="literal">True</span>) + \</span><br><span class="line">                          (<span class="number">1</span> - object_mask) * K.binary_crossentropy(object_mask, raw_pred[..., <span class="number">4</span>:<span class="number">5</span>],</span><br><span class="line">                                                                    from_logits=<span class="literal">True</span>) * ignore_mask</span><br><span class="line">class_loss = object_mask * K.binary_crossentropy(true_class_probs, raw_pred[..., <span class="number">5</span>:], from_logits=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">xy_loss = K.<span class="built_in">sum</span>(xy_loss) / mf</span><br><span class="line">wh_loss = K.<span class="built_in">sum</span>(wh_loss) / mf</span><br><span class="line">confidence_loss = K.<span class="built_in">sum</span>(confidence_loss) / mf</span><br><span class="line">class_loss = K.<span class="built_in">sum</span>(class_loss) / mf</span><br><span class="line">loss += xy_loss + wh_loss + confidence_loss + class_loss</span><br></pre></td></tr></table></figure><p>以上是一段keras框架描述的yolo v3 的loss_function代码。忽略恒定系数不看，可以从上述代码看出：除了w, h的损失函数依然采用总方误差之外，其他部分的损失函数用的是二值交叉熵(binary_crossentropy),最后加到一起。关于binary_crossentropy的公式详情可参考博文<a href="https://blog.csdn.net/legalhighhigh/article/details/81409551">《常见的损失函数》</a>。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="四、精度与性能"><a href="#四、精度与性能" class="headerlink" title="四、精度与性能"></a>四、精度与性能</h1><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202007/1534055-20200727232944334-1585239940.png" alt="图8：精度对比图(on coco)" style="zoom:50%;" /><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202007/1534055-20200727232825488-415229885.png" alt="图9：性能对比图(on coco)" style="zoom:30%;" /><p>由以上两图可以得到结论：Yolov3精度与SSD相比略有小优，与Faster R-CNN相比略有逊色，几乎持平，比RetinaNet差。但是速度是SSD、RetinaNet、Faster R-CNN至少2倍以上。输入尺寸为320*320的Yolov3，单张图片处理仅需22ms，简化后的Yolov3 tiny可以更快。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="五、代码实现"><a href="#五、代码实现" class="headerlink" title="五、代码实现"></a>五、代码实现</h1><h2 id="5-1-权重文件准备"><a href="#5-1-权重文件准备" class="headerlink" title="5.1 权重文件准备"></a>5.1 权重文件准备</h2><ol><li><p>第一步：下载权重文件</p><ul><li>git clone <a href="https://github.com/mystic123/tensorflow-yolo-v3.git">https://github.com/mystic123/tensorflow-yolo-v3.git</a></li></ul></li><li><p>第二步：权重文件格式转换</p><ul><li><p>切换到tensorflow-yolo-v3目录，保证在这个文件夹下面有<code>coco.names</code>和<code>yolov3.weights</code>两个文件</p></li><li><p>在当前目录打开TF1.14环境的Anaconda Prompt ，执行如下转换程序</p><ul><li><p><strong>转换成ckpt文件格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python convert_weights.py --class_names coco.names --data_format NHWC --weights_file yolov3.weights</span><br></pre></td></tr></table></figure><p>效果：　默认在当前文件夹下新建一个saved_model文件夹，里面是转换生成的文件</p></li><li><p><strong>转换成pb文件格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python convert_weights_pb.py --class_names coco.names --data_format NHWC --weights_file yolov3.weights</span><br></pre></td></tr></table></figure><p>效果：默认在当前文件夹下生成一个<code>frozen_darknet_yolov3_model.pb</code>文件</p></li></ul></li></ul></li></ol><p>　        <font color=orange>如果是转换自己训练的数据集，则将coco.names和yolov3.weights替换成自己相应的文件就可以了。　</font></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="5-2-代码结构"><a href="#5-2-代码结构" class="headerlink" title="5.2 代码结构"></a>5.2 代码结构</h2><p>tensorflow版本为1.14 。代码结构如图10所示。</p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/28/akGifU.png" alt="图10：代码结构" style="zoom:80%;" /><p>工程只有三个程序文件，其中<code>v3_model.py</code>为模型骨架，因为过于复杂，把它单独分离出来。<code>v3_pic.py</code>和<code>v3_video.py</code>分别是检测图片和检测视频的程序。</p><p>model文件夹中存放转化好的权重文件；output文件夹存放视频检测后输出的每一帧图片；test文件夹存放测试样例；font文件夹存放字体。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="5-3-公共模型"><a href="#5-3-公共模型" class="headerlink" title="5.3 公共模型"></a>5.3 公共模型</h2><p><font color=red>v3_model.py</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">slim = tf.contrib.slim</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义darknet块：一个短链接加一个同尺度卷积再加一个下采样卷积</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_darknet53_block</span>(<span class="params">inputs, filters</span>):</span></span><br><span class="line">    shortcut = inputs</span><br><span class="line">    inputs = slim.conv2d(inputs, filters, <span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="string">&#x27;SAME&#x27;</span>)<span class="comment">#正常卷积</span></span><br><span class="line">    inputs = slim.conv2d(inputs, filters * <span class="number">2</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="string">&#x27;SAME&#x27;</span>)<span class="comment">#正常卷积</span></span><br><span class="line"></span><br><span class="line">    inputs = inputs + shortcut</span><br><span class="line">    <span class="keyword">return</span> inputs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_conv2d_fixed_padding</span>(<span class="params">inputs, filters, kernel_size, strides=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> strides&gt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    inputs = _fixed_padding(inputs, kernel_size)<span class="comment">#外围填充0，好支持valid卷积</span></span><br><span class="line">    inputs = slim.conv2d(inputs, filters, kernel_size, stride=strides, padding= <span class="string">&#x27;VALID&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inputs</span><br><span class="line"></span><br><span class="line"><span class="comment">#对指定输入填充0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_fixed_padding</span>(<span class="params">inputs, kernel_size, *args, mode=<span class="string">&#x27;CONSTANT&#x27;</span>, **kwargs</span>):</span></span><br><span class="line">    pad_total = kernel_size - <span class="number">1</span></span><br><span class="line">    pad_beg = pad_total // <span class="number">2</span></span><br><span class="line">    pad_end = pad_total - pad_beg</span><br><span class="line"></span><br><span class="line">    <span class="comment">#inputs 【b,h,w,c】  pad  b,c不变。h和w上下左右，填充0.kernel = 3 ，则上下左右各加一趟0</span></span><br><span class="line">    padded_inputs = tf.pad(inputs, [[<span class="number">0</span>, <span class="number">0</span>], [pad_beg, pad_end],</span><br><span class="line">                                    [pad_beg, pad_end], [<span class="number">0</span>, <span class="number">0</span>]], mode=mode)</span><br><span class="line">    <span class="keyword">return</span> padded_inputs</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义Darknet-53 模型.返回3个不同尺度的特征</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">darknet53</span>(<span class="params">inputs</span>):</span></span><br><span class="line">    inputs = slim.conv2d(inputs, <span class="number">32</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="string">&#x27;SAME&#x27;</span>)<span class="comment">#正常卷积</span></span><br><span class="line">    inputs = _conv2d_fixed_padding(inputs, <span class="number">64</span>, <span class="number">3</span>, strides=<span class="number">2</span>)<span class="comment">#需要填充,并使用了&#x27;VALID&#x27; (-1, 208, 208, 64)</span></span><br><span class="line">    </span><br><span class="line">    inputs = _darknet53_block(inputs, <span class="number">32</span>)<span class="comment">#darknet块</span></span><br><span class="line">    inputs = _conv2d_fixed_padding(inputs, <span class="number">128</span>, <span class="number">3</span>, strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        inputs = _darknet53_block(inputs, <span class="number">64</span>)</span><br><span class="line">    inputs = _conv2d_fixed_padding(inputs, <span class="number">256</span>, <span class="number">3</span>, strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        inputs = _darknet53_block(inputs, <span class="number">128</span>)</span><br><span class="line">    route_1 = inputs  <span class="comment">#特征1 (-1, 52, 52, 128)</span></span><br><span class="line"></span><br><span class="line">    inputs = _conv2d_fixed_padding(inputs, <span class="number">512</span>, <span class="number">3</span>, strides=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        inputs = _darknet53_block(inputs, <span class="number">256</span>)</span><br><span class="line">    route_2 = inputs<span class="comment">#特征2  (-1, 26, 26, 256)</span></span><br><span class="line"></span><br><span class="line">    inputs = _conv2d_fixed_padding(inputs, <span class="number">1024</span>, <span class="number">3</span>, strides=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        inputs = _darknet53_block(inputs, <span class="number">512</span>)<span class="comment">#特征3 (-1, 13, 13, 512)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> route_1, route_2, inputs<span class="comment">#在原有的darknet53，还会跟一个全局池化。这里没有使用。所以其实是只有52层</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_BATCH_NORM_DECAY = <span class="number">0.9</span></span><br><span class="line">_BATCH_NORM_EPSILON = <span class="number">1e-05</span></span><br><span class="line">_LEAKY_RELU = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义候选框，来自coco数据集</span></span><br><span class="line">_ANCHORS = [(<span class="number">10</span>, <span class="number">13</span>), (<span class="number">16</span>, <span class="number">30</span>), (<span class="number">33</span>, <span class="number">23</span>), (<span class="number">30</span>, <span class="number">61</span>), (<span class="number">62</span>, <span class="number">45</span>), (<span class="number">59</span>, <span class="number">119</span>), (<span class="number">116</span>, <span class="number">90</span>), (<span class="number">156</span>, <span class="number">198</span>), (<span class="number">373</span>, <span class="number">326</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#yolo检测块</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_yolo_block</span>(<span class="params">inputs, filters</span>):</span></span><br><span class="line">    inputs = slim.conv2d(inputs, filters, <span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="string">&#x27;SAME&#x27;</span>)<span class="comment">#正常卷积</span></span><br><span class="line">    inputs = slim.conv2d(inputs, filters * <span class="number">2</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="string">&#x27;SAME&#x27;</span>)<span class="comment">#正常卷积</span></span><br><span class="line">    inputs = slim.conv2d(inputs, filters, <span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="string">&#x27;SAME&#x27;</span>)<span class="comment">#正常卷积</span></span><br><span class="line">    inputs = slim.conv2d(inputs, filters * <span class="number">2</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="string">&#x27;SAME&#x27;</span>)<span class="comment">#正常卷积 </span></span><br><span class="line">    inputs = slim.conv2d(inputs, filters, <span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="string">&#x27;SAME&#x27;</span>)<span class="comment">#正常卷积</span></span><br><span class="line">    route = inputs</span><br><span class="line">    inputs = slim.conv2d(inputs, filters * <span class="number">2</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="string">&#x27;SAME&#x27;</span>)<span class="comment">#正常卷积 </span></span><br><span class="line">    <span class="keyword">return</span> route, inputs</span><br><span class="line"></span><br><span class="line"><span class="comment">#检测层</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_detection_layer</span>(<span class="params">inputs, num_classes, anchors, img_size, data_format</span>):</span></span><br><span class="line">    print(inputs.get_shape())</span><br><span class="line">    num_anchors = <span class="built_in">len</span>(anchors)<span class="comment">#候选框个数</span></span><br><span class="line">    predictions = slim.conv2d(inputs, num_anchors * (<span class="number">5</span> + num_classes), <span class="number">1</span>, stride=<span class="number">1</span>, normalizer_fn=<span class="literal">None</span>,</span><br><span class="line">                              activation_fn=<span class="literal">None</span>, biases_initializer=tf.zeros_initializer())</span><br><span class="line"></span><br><span class="line">    shape = predictions.get_shape().as_list()</span><br><span class="line">    print(<span class="string">&quot;shape&quot;</span>,shape)<span class="comment">#三个尺度的形状分别为：[1, 13, 13, 3*(5+c)]、[1, 26, 26, 3*(5+c)]、[1, 52, 52, 3*(5+c)]</span></span><br><span class="line">    grid_size = shape[<span class="number">1</span>:<span class="number">3</span>]<span class="comment">#去 NHWC中的HW</span></span><br><span class="line">    dim = grid_size[<span class="number">0</span>] * grid_size[<span class="number">1</span>]<span class="comment">#每个格子所包含的像素</span></span><br><span class="line">    bbox_attrs = <span class="number">5</span> + num_classes</span><br><span class="line"></span><br><span class="line">    predictions = tf.reshape(predictions, [-<span class="number">1</span>, num_anchors * dim, bbox_attrs])<span class="comment">#把h和w展开成dim</span></span><br><span class="line"></span><br><span class="line">    stride = (img_size[<span class="number">0</span>] // grid_size[<span class="number">0</span>], img_size[<span class="number">1</span>] // grid_size[<span class="number">1</span>])<span class="comment">#缩放参数 32（416/13）</span></span><br><span class="line"></span><br><span class="line">    anchors = [(a[<span class="number">0</span>] / stride[<span class="number">0</span>], a[<span class="number">1</span>] / stride[<span class="number">1</span>]) <span class="keyword">for</span> a <span class="keyword">in</span> anchors]<span class="comment">#将候选框的尺寸同比例缩小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#将包含边框的单元属性拆分</span></span><br><span class="line">    box_centers, box_sizes, confidence, classes = tf.split(predictions, [<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, num_classes], axis=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    box_centers = tf.nn.sigmoid(box_centers)</span><br><span class="line">    confidence = tf.nn.sigmoid(confidence)</span><br><span class="line"></span><br><span class="line">    grid_x = tf.<span class="built_in">range</span>(grid_size[<span class="number">0</span>], dtype=tf.float32)<span class="comment">#定义网格索引0,1,2...n</span></span><br><span class="line">    grid_y = tf.<span class="built_in">range</span>(grid_size[<span class="number">1</span>], dtype=tf.float32)<span class="comment">#定义网格索引0,1,2,...m</span></span><br><span class="line">    a, b = tf.meshgrid(grid_x, grid_y)<span class="comment">#生成网格矩阵 a0，a1.。。an（共M行）  ， b0，b0，。。。b0（共n个），第二行为b1</span></span><br><span class="line"></span><br><span class="line">    x_offset = tf.reshape(a, (-<span class="number">1</span>, <span class="number">1</span>))<span class="comment">#展开 一共dim个</span></span><br><span class="line">    y_offset = tf.reshape(b, (-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    x_y_offset = tf.concat([x_offset, y_offset], axis=-<span class="number">1</span>)<span class="comment">#连接----[dim,2]</span></span><br><span class="line">    x_y_offset = tf.reshape(tf.tile(x_y_offset, [<span class="number">1</span>, num_anchors]), [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>])<span class="comment">#按候选框的个数复制xy（【1，n】代表第0维一次，第1维n次）</span></span><br><span class="line"></span><br><span class="line">    box_centers = box_centers + x_y_offset<span class="comment">#box_centers为0-1，x_y为具体网格的索引，相加后，就是真实位置(0.1+4=4.1，第4个网格里0.1的偏移)</span></span><br><span class="line">    box_centers = box_centers * stride<span class="comment">#真实尺寸像素点</span></span><br><span class="line"></span><br><span class="line">    anchors = tf.tile(anchors, [dim, <span class="number">1</span>])</span><br><span class="line">    box_sizes = tf.exp(box_sizes) * anchors<span class="comment">#计算边长：hw</span></span><br><span class="line">    box_sizes = box_sizes * stride<span class="comment">#真实边长</span></span><br><span class="line"></span><br><span class="line">    detections = tf.concat([box_centers, box_sizes, confidence], axis=-<span class="number">1</span>)</span><br><span class="line">    classes = tf.nn.sigmoid(classes)</span><br><span class="line">    predictions = tf.concat([detections, classes], axis=-<span class="number">1</span>)<span class="comment">#将转化后的结果合起来</span></span><br><span class="line">    print(predictions.get_shape())<span class="comment">#三个尺度的形状分别为：[1, 507（13*13*3）, 5+c]、[1, 2028, 5+c]、[1, 8112, 5+c]</span></span><br><span class="line">    <span class="keyword">return</span> predictions<span class="comment">#返回预测值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义上采样函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_upsample</span>(<span class="params">inputs, out_shape</span>):</span></span><br><span class="line">    <span class="comment">#由于上采样的填充方式不同，tf.image.resize_bilinear会对结果影响很大</span></span><br><span class="line">    inputs = tf.image.resize_nearest_neighbor(inputs, (out_shape[<span class="number">1</span>], out_shape[<span class="number">2</span>]))</span><br><span class="line">    inputs = tf.identity(inputs, name=<span class="string">&#x27;upsampled&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> inputs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义yolo函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yolo_v3</span>(<span class="params">inputs, num_classes, is_training=<span class="literal">False</span>, data_format=<span class="string">&#x27;NHWC&#x27;</span>, reuse=<span class="literal">False</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> data_format==<span class="string">&#x27;NHWC&#x27;</span></span><br><span class="line">    </span><br><span class="line">    img_size = inputs.get_shape().as_list()[<span class="number">1</span>:<span class="number">3</span>]<span class="comment">#获得输入图片大小</span></span><br><span class="line"></span><br><span class="line">    inputs = inputs / <span class="number">255</span>    <span class="comment">#归一化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义批量归一化参数</span></span><br><span class="line">    batch_norm_params = &#123;</span><br><span class="line">        <span class="string">&#x27;decay&#x27;</span>: _BATCH_NORM_DECAY,</span><br><span class="line">        <span class="string">&#x27;epsilon&#x27;</span>: _BATCH_NORM_EPSILON,</span><br><span class="line">        <span class="string">&#x27;scale&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&#x27;is_training&#x27;</span>: is_training,</span><br><span class="line">        <span class="string">&#x27;fused&#x27;</span>: <span class="literal">None</span>,  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义yolo网络.</span></span><br><span class="line">    <span class="keyword">with</span> slim.arg_scope([slim.conv2d, slim.batch_norm], data_format=data_format, reuse=reuse):</span><br><span class="line">        <span class="keyword">with</span> slim.arg_scope([slim.conv2d], normalizer_fn=slim.batch_norm, normalizer_params=batch_norm_params,</span><br><span class="line">                            biases_initializer=<span class="literal">None</span>, activation_fn=<span class="keyword">lambda</span> x: tf.nn.leaky_relu(x, alpha=_LEAKY_RELU)):</span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;darknet-53&#x27;</span>):</span><br><span class="line">                route_1, route_2, inputs = darknet53(inputs)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;yolo-v3&#x27;</span>):</span><br><span class="line">                route, inputs = _yolo_block(inputs, <span class="number">512</span>)<span class="comment">#(-1, 13, 13, 1024)</span></span><br><span class="line">                <span class="comment">#使用候选框参数来辅助识别</span></span><br><span class="line">                detect_1 = _detection_layer(inputs, num_classes, _ANCHORS[<span class="number">6</span>:<span class="number">9</span>], img_size, data_format)</span><br><span class="line">                detect_1 = tf.identity(detect_1, name=<span class="string">&#x27;detect_1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                inputs = slim.conv2d(route, <span class="number">256</span>, <span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="string">&#x27;SAME&#x27;</span>)<span class="comment">#正常卷积 </span></span><br><span class="line">                upsample_size = route_2.get_shape().as_list()</span><br><span class="line">                inputs = _upsample(inputs, upsample_size)</span><br><span class="line">                inputs = tf.concat([inputs, route_2], axis=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">                route, inputs = _yolo_block(inputs, <span class="number">256</span>)<span class="comment">#(-1, 26, 26, 512)</span></span><br><span class="line">                detect_2 = _detection_layer(inputs, num_classes, _ANCHORS[<span class="number">3</span>:<span class="number">6</span>], img_size, data_format)</span><br><span class="line">                detect_2 = tf.identity(detect_2, name=<span class="string">&#x27;detect_2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                inputs = slim.conv2d(route, <span class="number">128</span>, <span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="string">&#x27;SAME&#x27;</span>)<span class="comment">#正常卷积</span></span><br><span class="line">                upsample_size = route_1.get_shape().as_list()</span><br><span class="line">                inputs = _upsample(inputs, upsample_size)</span><br><span class="line">                inputs = tf.concat([inputs, route_1], axis=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">                _, inputs = _yolo_block(inputs, <span class="number">128</span>)<span class="comment">#(-1, 52, 52, 256)</span></span><br><span class="line"></span><br><span class="line">                detect_3 = _detection_layer(inputs, num_classes, _ANCHORS[<span class="number">0</span>:<span class="number">3</span>], img_size, data_format)</span><br><span class="line">                detect_3 = tf.identity(detect_3, name=<span class="string">&#x27;detect_3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                detections = tf.concat([detect_1, detect_2, detect_3], axis=<span class="number">1</span>)</span><br><span class="line">                detections = tf.identity(detections, name=<span class="string">&#x27;detections&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> detections<span class="comment">#返回了3个尺度。每个尺度里又包含3个结果(-1, 10647（ 507 +2028 + 8112）, 5+c)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;--------Test--------&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># if __name__ == &quot;__main__&quot;:</span></span><br><span class="line"><span class="comment">#     tf.reset_default_graph()</span></span><br><span class="line"><span class="comment">#     import cv2</span></span><br><span class="line"><span class="comment">#     data = cv2.imread(&#x27;test.jpg&#x27;)</span></span><br><span class="line"><span class="comment">#     data = cv2.cvtColor( data, cv2.COLOR_BGR2RGB )</span></span><br><span class="line"><span class="comment">#     data = cv2.resize( data, ( 416, 416 ) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     data = tf.cast( tf.expand_dims( tf.constant( data ), 0 ), tf.float32 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     detections = yolo_v3( data,3,data_format=&#x27;NHWC&#x27; )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     with tf.Session() as sess:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#         sess.run( tf.global_variables_initializer() )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#         print( sess.run( detections ).shape )</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h2 id="5-4-基于图片的目标检测"><a href="#5-4-基于图片的目标检测" class="headerlink" title="5.4 基于图片的目标检测"></a>5.4 基于图片的目标检测</h2><p><font color=red>v3_pic.py</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line">my_model = <span class="built_in">__import__</span>(<span class="string">&quot;v3_model&quot;</span>)</span><br><span class="line">yolo_v3 = my_model.yolo_v3</span><br><span class="line"></span><br><span class="line">size = <span class="number">416</span></span><br><span class="line">input_img =<span class="string">&#x27;D:\\计算机视觉\\已完成的代码\\yolo\\test\\6.jpg&#x27;</span></span><br><span class="line">output_img = <span class="string">&#x27;out.jpg&#x27;</span></span><br><span class="line">class_names = <span class="string">&#x27;D:\\计算机视觉\\已完成的代码\\yolo\\model\\v3\\coco.names&#x27;</span></span><br><span class="line">weights_file = <span class="string">&#x27;D:\\计算机视觉\\已完成的代码\\yolo\\model\\v3\\yolov3.weights&#x27;</span></span><br><span class="line">conf_threshold = <span class="number">0.5</span> <span class="comment">#置信度阈值</span></span><br><span class="line">iou_threshold = <span class="number">0.4</span>  <span class="comment">#重叠区域阈值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义函数：将中心点、高、宽坐标 转化为[x0, y0, x1, y1]坐标形式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detections_boxes</span>(<span class="params">detections</span>):</span></span><br><span class="line">    center_x, center_y, width, height, attrs = tf.split(detections, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>], axis=-<span class="number">1</span>)</span><br><span class="line">    w2 = width / <span class="number">2</span></span><br><span class="line">    h2 = height / <span class="number">2</span></span><br><span class="line">    x0 = center_x - w2</span><br><span class="line">    y0 = center_y - h2</span><br><span class="line">    x1 = center_x + w2</span><br><span class="line">    y1 = center_y + h2</span><br><span class="line"></span><br><span class="line">    boxes = tf.concat([x0, y0, x1, y1], axis=-<span class="number">1</span>)</span><br><span class="line">    detections = tf.concat([boxes, attrs], axis=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> detections</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义函数计算两个框的内部重叠情况（IOU）box1，box2为左上、右下的坐标[x0, y0, x1, x2]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_iou</span>(<span class="params">box1, box2</span>):</span></span><br><span class="line"></span><br><span class="line">    b1_x0, b1_y0, b1_x1, b1_y1 = box1</span><br><span class="line">    b2_x0, b2_y0, b2_x1, b2_y1 = box2</span><br><span class="line"></span><br><span class="line">    int_x0 = <span class="built_in">max</span>(b1_x0, b2_x0)</span><br><span class="line">    int_y0 = <span class="built_in">max</span>(b1_y0, b2_y0)</span><br><span class="line">    int_x1 = <span class="built_in">min</span>(b1_x1, b2_x1)</span><br><span class="line">    int_y1 = <span class="built_in">min</span>(b1_y1, b2_y1)</span><br><span class="line"></span><br><span class="line">    int_area = (int_x1 - int_x0) * (int_y1 - int_y0)</span><br><span class="line"></span><br><span class="line">    b1_area = (b1_x1 - b1_x0) * (b1_y1 - b1_y0)</span><br><span class="line">    b2_area = (b2_x1 - b2_x0) * (b2_y1 - b2_y0)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#分母加个1e-05，避免除数为 0</span></span><br><span class="line">    iou = int_area / (b1_area + b2_area - int_area + <span class="number">1e-05</span>)</span><br><span class="line">    <span class="keyword">return</span> iou</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用NMS方法，对结果去重</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">non_max_suppression</span>(<span class="params">predictions_with_boxes, confidence_threshold, iou_threshold=<span class="number">0.4</span></span>):</span></span><br><span class="line"></span><br><span class="line">    conf_mask = np.expand_dims((predictions_with_boxes[:, :, <span class="number">4</span>] &gt; confidence_threshold), -<span class="number">1</span>)</span><br><span class="line">    predictions = predictions_with_boxes * conf_mask</span><br><span class="line"></span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, image_pred <span class="keyword">in</span> <span class="built_in">enumerate</span>(predictions):</span><br><span class="line">        shape = image_pred.shape</span><br><span class="line">        <span class="comment">#print(&quot;shape1&quot;,shape)</span></span><br><span class="line">        non_zero_idxs = np.nonzero(image_pred)</span><br><span class="line">        image_pred = image_pred[non_zero_idxs[<span class="number">0</span>]]</span><br><span class="line">        <span class="comment">#print(&quot;shape2&quot;,image_pred.shape)</span></span><br><span class="line">        image_pred = image_pred.reshape(-<span class="number">1</span>, shape[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        bbox_attrs = image_pred[:, :<span class="number">5</span>]</span><br><span class="line">        classes = image_pred[:, <span class="number">5</span>:]</span><br><span class="line">        classes = np.argmax(classes, axis=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        unique_classes = <span class="built_in">list</span>(<span class="built_in">set</span>(classes.reshape(-<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cls <span class="keyword">in</span> unique_classes:</span><br><span class="line">            cls_mask = classes == cls</span><br><span class="line">            cls_boxes = bbox_attrs[np.nonzero(cls_mask)]</span><br><span class="line">            cls_boxes = cls_boxes[cls_boxes[:, -<span class="number">1</span>].argsort()[::-<span class="number">1</span>]]</span><br><span class="line">            cls_scores = cls_boxes[:, -<span class="number">1</span>]</span><br><span class="line">            cls_boxes = cls_boxes[:, :-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(cls_boxes) &gt; <span class="number">0</span>:</span><br><span class="line">                box = cls_boxes[<span class="number">0</span>]</span><br><span class="line">                score = cls_scores[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cls <span class="keyword">in</span> result:</span><br><span class="line">                    result[cls] = []</span><br><span class="line">                result[cls].append((box, score))</span><br><span class="line">                cls_boxes = cls_boxes[<span class="number">1</span>:]</span><br><span class="line">                ious = np.array([_iou(box, x) <span class="keyword">for</span> x <span class="keyword">in</span> cls_boxes])</span><br><span class="line">                iou_mask = ious &lt; iou_threshold</span><br><span class="line">                cls_boxes = cls_boxes[np.nonzero(iou_mask)]</span><br><span class="line">                cls_scores = cls_scores[np.nonzero(iou_mask)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#加载权重</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_weights</span>(<span class="params">var_list, weights_file</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(weights_file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        _ = np.fromfile(fp, dtype=np.int32, count=<span class="number">5</span>)<span class="comment">#跳过前5个int32</span></span><br><span class="line">        weights = np.fromfile(fp, dtype=np.float32)</span><br><span class="line"></span><br><span class="line">    ptr = <span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    assign_ops = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(var_list) - <span class="number">1</span>:</span><br><span class="line">        var1 = var_list[i]</span><br><span class="line">        var2 = var_list[i + <span class="number">1</span>]</span><br><span class="line">        <span class="comment">#找到卷积项</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;Conv&#x27;</span> <span class="keyword">in</span> var1.name.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">2</span>]:</span><br><span class="line">            <span class="comment"># 找到BN参数项</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;BatchNorm&#x27;</span> <span class="keyword">in</span> var2.name.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">2</span>]:</span><br><span class="line">                <span class="comment"># 加载批量归一化参数</span></span><br><span class="line">                gamma, beta, mean, var = var_list[i + <span class="number">1</span>:i + <span class="number">5</span>]</span><br><span class="line">                batch_norm_vars = [beta, gamma, mean, var]</span><br><span class="line">                <span class="keyword">for</span> var <span class="keyword">in</span> batch_norm_vars:</span><br><span class="line">                    shape = var.shape.as_list()</span><br><span class="line">                    num_params = np.prod(shape)</span><br><span class="line">                    var_weights = weights[ptr:ptr + num_params].reshape(shape)</span><br><span class="line">                    ptr += num_params</span><br><span class="line">                    assign_ops.append(tf.assign(var, var_weights, validate_shape=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">                i += <span class="number">4</span><span class="comment">#已经加载了4个变量，指针移动4</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&#x27;Conv&#x27;</span> <span class="keyword">in</span> var2.name.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">2</span>]:</span><br><span class="line">                bias = var2</span><br><span class="line">                bias_shape = bias.shape.as_list()</span><br><span class="line">                bias_params = np.prod(bias_shape)</span><br><span class="line">                bias_weights = weights[ptr:ptr + bias_params].reshape(bias_shape)</span><br><span class="line">                ptr += bias_params</span><br><span class="line">                assign_ops.append(tf.assign(bias, bias_weights, validate_shape=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">                i += <span class="number">1</span><span class="comment">#移动指针</span></span><br><span class="line"></span><br><span class="line">            shape = var1.shape.as_list()</span><br><span class="line">            num_params = np.prod(shape)</span><br><span class="line">            <span class="comment">#加载权重</span></span><br><span class="line">            var_weights = weights[ptr:ptr + num_params].reshape((shape[<span class="number">3</span>], shape[<span class="number">2</span>], shape[<span class="number">0</span>], shape[<span class="number">1</span>]))</span><br><span class="line">            var_weights = np.transpose(var_weights, (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">            ptr += num_params</span><br><span class="line">            assign_ops.append(tf.assign(var1, var_weights, validate_shape=<span class="literal">True</span>))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> assign_ops</span><br><span class="line"></span><br><span class="line"><span class="comment">#将级别结果显示在图片上</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_boxes</span>(<span class="params">boxes, img, cls_names, detection_size</span>):</span></span><br><span class="line">    draw = ImageDraw.Draw(img)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> cls, bboxs <span class="keyword">in</span> boxes.items():</span><br><span class="line">        color = <span class="built_in">tuple</span>(np.random.randint(<span class="number">0</span>, <span class="number">256</span>, <span class="number">3</span>))     <span class="comment">#为每一个识别到的物体各设置一种颜色</span></span><br><span class="line">        <span class="keyword">for</span> box, score <span class="keyword">in</span> bboxs:</span><br><span class="line">            box = convert_to_original_size(box, np.array(detection_size), np.array(img.size))</span><br><span class="line">            draw.rectangle(box, outline=color, width=<span class="number">3</span>)</span><br><span class="line">         </span><br><span class="line">            <span class="comment">#fontText = ImageFont.truetype(&quot;./font/simhei.ttf&quot;, textSize, encoding=&quot;utf-8&quot;)</span></span><br><span class="line">            fontText = ImageFont.truetype(<span class="string">&#x27;./font/simhei.ttf&#x27;</span>, <span class="number">30</span>)  <span class="comment">#设置字体大小</span></span><br><span class="line">            draw.text(box[:<span class="number">2</span>], <span class="string">&#x27;&#123;&#125; &#123;:.2f&#125;%&#x27;</span>.<span class="built_in">format</span>(cls_names[cls], score * <span class="number">100</span>), fill=color,font=fontText)</span><br><span class="line"></span><br><span class="line">            print(cls_names[cls].replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>) , <span class="string">&#x27;&#123;:.2f&#125;%&#x27;</span>.<span class="built_in">format</span>( score * <span class="number">100</span>),box[:<span class="number">2</span>])</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_to_original_size</span>(<span class="params">box, size, original_size</span>):</span></span><br><span class="line">    ratio = original_size / size</span><br><span class="line">    box = box.reshape(<span class="number">2</span>, <span class="number">2</span>) * ratio</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(box.reshape(-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#加载数据集标签名称</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_coco_names</span>(<span class="params">file_name</span>):</span></span><br><span class="line">    names = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">id</span>, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(f):</span><br><span class="line">            names[<span class="built_in">id</span>] = name</span><br><span class="line">    <span class="keyword">return</span> names</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv=<span class="literal">None</span></span>):</span></span><br><span class="line">    tf.reset_default_graph()</span><br><span class="line">    img = Image.<span class="built_in">open</span>(input_img)</span><br><span class="line">    img_resized = img.resize(size=(size, size))</span><br><span class="line"></span><br><span class="line">    classes = load_coco_names(class_names)      <span class="comment">#这里的读取到的名字，都跟着一个换行符，可以使用.replace(&#x27;\n&#x27;, &#x27;&#x27;)删掉它</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义输入占位符</span></span><br><span class="line">    inputs = tf.placeholder(tf.float32, [<span class="literal">None</span>, size, size, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;detector&#x27;</span>):</span><br><span class="line">        detections = yolo_v3(inputs, <span class="built_in">len</span>(classes), data_format=<span class="string">&#x27;NHWC&#x27;</span>)<span class="comment">#定义网络结构</span></span><br><span class="line">        <span class="comment">#加载权重</span></span><br><span class="line">        load_ops = load_weights(tf.global_variables(scope=<span class="string">&#x27;detector&#x27;</span>), weights_file)</span><br><span class="line"></span><br><span class="line">    boxes = detections_boxes(detections)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        sess.run(load_ops)</span><br><span class="line"></span><br><span class="line">        detected_boxes = sess.run(boxes, feed_dict=&#123;inputs: [np.array(img_resized, dtype=np.float32)]&#125;)</span><br><span class="line">    <span class="comment">#对10647个预测框进行去重</span></span><br><span class="line">    filtered_boxes = non_max_suppression(detected_boxes, confidence_threshold=conf_threshold,</span><br><span class="line">                                         iou_threshold=iou_threshold)</span><br><span class="line"></span><br><span class="line">    draw_boxes(filtered_boxes, img, classes, (size, size))</span><br><span class="line"></span><br><span class="line">    img.save(output_img)</span><br><span class="line">    img.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>测试1：</strong></p><p>先来一张合影照片，效果还不错。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/24/Uv8J8f.png"></p><p><strong>测试2：</strong></p><p>当然，有一张图片在v1、v2中都检测失败了，这次肯定还要拿出来试一试，很开心在v3的实验中检测到了一些东西，虽说把电动三轮车识别成了truck和bus……</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/24/Uv8GPP.png"></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="5-5-基于视频的目标检测"><a href="#5-5-基于视频的目标检测" class="headerlink" title="5.5 基于视频的目标检测"></a>5.5 基于视频的目标检测</h2><p><font color=red>v3_video.py</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line">my_model = <span class="built_in">__import__</span>(<span class="string">&quot;v3_model&quot;</span>)</span><br><span class="line">yolo_v3 = my_model.yolo_v3</span><br><span class="line"></span><br><span class="line">size = <span class="number">416</span></span><br><span class="line">input_video =<span class="string">&#x27;D:\\计算机视觉\\已完成的代码\\yolo\\test\\3.mp4&#x27;</span></span><br><span class="line">class_names = <span class="string">&#x27;D:\\计算机视觉\\已完成的代码\\yolo\\model\\v3\\coco.names&#x27;</span></span><br><span class="line">weights_file = <span class="string">&#x27;D:\\计算机视觉\\已完成的代码\\yolo\\model\\v3\\yolov3.weights&#x27;</span></span><br><span class="line">conf_threshold = <span class="number">0.5</span> <span class="comment">#置信度阈值</span></span><br><span class="line">iou_threshold = <span class="number">0.4</span>  <span class="comment">#重叠区域阈值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义函数：将中心点、高、宽坐标 转化为[x0, y0, x1, y1]坐标形式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detections_boxes</span>(<span class="params">detections</span>):</span></span><br><span class="line">    center_x, center_y, width, height, attrs = tf.split(detections, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>], axis=-<span class="number">1</span>)</span><br><span class="line">    w2 = width / <span class="number">2</span></span><br><span class="line">    h2 = height / <span class="number">2</span></span><br><span class="line">    x0 = center_x - w2</span><br><span class="line">    y0 = center_y - h2</span><br><span class="line">    x1 = center_x + w2</span><br><span class="line">    y1 = center_y + h2</span><br><span class="line"></span><br><span class="line">    boxes = tf.concat([x0, y0, x1, y1], axis=-<span class="number">1</span>)</span><br><span class="line">    detections = tf.concat([boxes, attrs], axis=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> detections</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义函数计算两个框的内部重叠情况（IOU）box1，box2为左上、右下的坐标[x0, y0, x1, x2]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_iou</span>(<span class="params">box1, box2</span>):</span></span><br><span class="line"></span><br><span class="line">    b1_x0, b1_y0, b1_x1, b1_y1 = box1</span><br><span class="line">    b2_x0, b2_y0, b2_x1, b2_y1 = box2</span><br><span class="line"></span><br><span class="line">    int_x0 = <span class="built_in">max</span>(b1_x0, b2_x0)</span><br><span class="line">    int_y0 = <span class="built_in">max</span>(b1_y0, b2_y0)</span><br><span class="line">    int_x1 = <span class="built_in">min</span>(b1_x1, b2_x1)</span><br><span class="line">    int_y1 = <span class="built_in">min</span>(b1_y1, b2_y1)</span><br><span class="line"></span><br><span class="line">    int_area = (int_x1 - int_x0) * (int_y1 - int_y0)</span><br><span class="line"></span><br><span class="line">    b1_area = (b1_x1 - b1_x0) * (b1_y1 - b1_y0)</span><br><span class="line">    b2_area = (b2_x1 - b2_x0) * (b2_y1 - b2_y0)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#分母加个1e-05，避免除数为 0</span></span><br><span class="line">    iou = int_area / (b1_area + b2_area - int_area + <span class="number">1e-05</span>)</span><br><span class="line">    <span class="keyword">return</span> iou</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用NMS方法，对结果去重</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">non_max_suppression</span>(<span class="params">predictions_with_boxes, confidence_threshold, iou_threshold=<span class="number">0.4</span></span>):</span></span><br><span class="line"></span><br><span class="line">    conf_mask = np.expand_dims((predictions_with_boxes[:, :, <span class="number">4</span>] &gt; confidence_threshold), -<span class="number">1</span>)</span><br><span class="line">    predictions = predictions_with_boxes * conf_mask</span><br><span class="line"></span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, image_pred <span class="keyword">in</span> <span class="built_in">enumerate</span>(predictions):</span><br><span class="line">        shape = image_pred.shape</span><br><span class="line">        <span class="comment">#print(&quot;shape1&quot;,shape)</span></span><br><span class="line">        non_zero_idxs = np.nonzero(image_pred)</span><br><span class="line">        image_pred = image_pred[non_zero_idxs[<span class="number">0</span>]]</span><br><span class="line">        <span class="comment">#print(&quot;shape2&quot;,image_pred.shape)</span></span><br><span class="line">        image_pred = image_pred.reshape(-<span class="number">1</span>, shape[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        bbox_attrs = image_pred[:, :<span class="number">5</span>]</span><br><span class="line">        classes = image_pred[:, <span class="number">5</span>:]</span><br><span class="line">        classes = np.argmax(classes, axis=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        unique_classes = <span class="built_in">list</span>(<span class="built_in">set</span>(classes.reshape(-<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cls <span class="keyword">in</span> unique_classes:</span><br><span class="line">            cls_mask = classes == cls</span><br><span class="line">            cls_boxes = bbox_attrs[np.nonzero(cls_mask)]</span><br><span class="line">            cls_boxes = cls_boxes[cls_boxes[:, -<span class="number">1</span>].argsort()[::-<span class="number">1</span>]]</span><br><span class="line">            cls_scores = cls_boxes[:, -<span class="number">1</span>]</span><br><span class="line">            cls_boxes = cls_boxes[:, :-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(cls_boxes) &gt; <span class="number">0</span>:</span><br><span class="line">                box = cls_boxes[<span class="number">0</span>]</span><br><span class="line">                score = cls_scores[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cls <span class="keyword">in</span> result:</span><br><span class="line">                    result[cls] = []</span><br><span class="line">                result[cls].append((box, score))</span><br><span class="line">                cls_boxes = cls_boxes[<span class="number">1</span>:]</span><br><span class="line">                ious = np.array([_iou(box, x) <span class="keyword">for</span> x <span class="keyword">in</span> cls_boxes])</span><br><span class="line">                iou_mask = ious &lt; iou_threshold</span><br><span class="line">                cls_boxes = cls_boxes[np.nonzero(iou_mask)]</span><br><span class="line">                cls_scores = cls_scores[np.nonzero(iou_mask)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#加载权重</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_weights</span>(<span class="params">var_list, weights_file</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(weights_file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        _ = np.fromfile(fp, dtype=np.int32, count=<span class="number">5</span>)<span class="comment">#跳过前5个int32</span></span><br><span class="line">        weights = np.fromfile(fp, dtype=np.float32)</span><br><span class="line"></span><br><span class="line">    ptr = <span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    assign_ops = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(var_list) - <span class="number">1</span>:</span><br><span class="line">        var1 = var_list[i]</span><br><span class="line">        var2 = var_list[i + <span class="number">1</span>]</span><br><span class="line">        <span class="comment">#找到卷积项</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;Conv&#x27;</span> <span class="keyword">in</span> var1.name.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">2</span>]:</span><br><span class="line">            <span class="comment"># 找到BN参数项</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;BatchNorm&#x27;</span> <span class="keyword">in</span> var2.name.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">2</span>]:</span><br><span class="line">                <span class="comment"># 加载批量归一化参数</span></span><br><span class="line">                gamma, beta, mean, var = var_list[i + <span class="number">1</span>:i + <span class="number">5</span>]</span><br><span class="line">                batch_norm_vars = [beta, gamma, mean, var]</span><br><span class="line">                <span class="keyword">for</span> var <span class="keyword">in</span> batch_norm_vars:</span><br><span class="line">                    shape = var.shape.as_list()</span><br><span class="line">                    num_params = np.prod(shape)</span><br><span class="line">                    var_weights = weights[ptr:ptr + num_params].reshape(shape)</span><br><span class="line">                    ptr += num_params</span><br><span class="line">                    assign_ops.append(tf.assign(var, var_weights, validate_shape=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">                i += <span class="number">4</span><span class="comment">#已经加载了4个变量，指针移动4</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&#x27;Conv&#x27;</span> <span class="keyword">in</span> var2.name.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">2</span>]:</span><br><span class="line">                bias = var2</span><br><span class="line">                bias_shape = bias.shape.as_list()</span><br><span class="line">                bias_params = np.prod(bias_shape)</span><br><span class="line">                bias_weights = weights[ptr:ptr + bias_params].reshape(bias_shape)</span><br><span class="line">                ptr += bias_params</span><br><span class="line">                assign_ops.append(tf.assign(bias, bias_weights, validate_shape=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">                i += <span class="number">1</span><span class="comment">#移动指针</span></span><br><span class="line"></span><br><span class="line">            shape = var1.shape.as_list()</span><br><span class="line">            num_params = np.prod(shape)</span><br><span class="line">            <span class="comment">#加载权重</span></span><br><span class="line">            var_weights = weights[ptr:ptr + num_params].reshape((shape[<span class="number">3</span>], shape[<span class="number">2</span>], shape[<span class="number">0</span>], shape[<span class="number">1</span>]))</span><br><span class="line">            var_weights = np.transpose(var_weights, (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">            ptr += num_params</span><br><span class="line">            assign_ops.append(tf.assign(var1, var_weights, validate_shape=<span class="literal">True</span>))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> assign_ops</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将级别结果显示在图片上</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_boxes</span>(<span class="params">j,boxes, img, cls_names, detection_size</span>):</span></span><br><span class="line">    draw = ImageDraw.Draw(img)</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;./output/final_v3.txt&#x27;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> cls, bboxs <span class="keyword">in</span> boxes.items():</span><br><span class="line">        <span class="comment">#color = tuple(np.random.randint(0, 256, 3))     #为每一个识别到的物体各设置一种颜色</span></span><br><span class="line">        <span class="keyword">for</span> box, score <span class="keyword">in</span> bboxs:</span><br><span class="line">            box = convert_to_original_size(box, np.array(detection_size), np.array(img.size))</span><br><span class="line">            draw.rectangle(box, outline=(<span class="number">30</span>,<span class="number">148</span>,<span class="number">147</span>), width=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            fontText = ImageFont.truetype(<span class="string">&#x27;./font/simhei.ttf&#x27;</span>, <span class="number">15</span>)  <span class="comment">#设置字体大小</span></span><br><span class="line">            draw.text(box[:<span class="number">2</span>], <span class="string">&#x27;&#123;&#125; &#123;:.2f&#125;%&#x27;</span>.<span class="built_in">format</span>(cls_names[cls], score * <span class="number">100</span>), fill=(<span class="number">30</span>,<span class="number">148</span>,<span class="number">147</span>),font=fontText)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#print(cls_names[cls].replace(&#x27;\n&#x27;, &#x27;&#x27;) , &#x27;&#123;:.2f&#125;%&#x27;.format( score * 100),box[:2])</span></span><br><span class="line">            </span><br><span class="line">            f.write(<span class="built_in">str</span>(cls_names[cls].replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)) +<span class="string">&#x27;    &#x27;</span>+ <span class="string">&#x27;&#123;:.2f&#125;%&#x27;</span>.<span class="built_in">format</span>( score * <span class="number">100</span>) +<span class="string">&#x27;    &#x27;</span>+ <span class="built_in">str</span>(box[:<span class="number">2</span>])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#cv2.imwrite(address,draw)</span></span><br><span class="line">        address = <span class="string">&#x27;./output/&#x27;</span> + <span class="built_in">str</span>(j)+ <span class="string">&#x27;.png&#x27;</span></span><br><span class="line">        img.save(address)</span><br><span class="line">        </span><br><span class="line">        f.write(<span class="string">&#x27;\n&#x27;</span>)    <span class="comment">#把每一个框分开</span></span><br><span class="line">    f.write(<span class="string">&#x27;\n\n\n\n\n\n\n\n\n\n\n\n&#x27;</span>)    <span class="comment">#把每一帧分开</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_to_original_size</span>(<span class="params">box, size, original_size</span>):</span></span><br><span class="line">    ratio = original_size / size</span><br><span class="line">    box = box.reshape(<span class="number">2</span>, <span class="number">2</span>) * ratio</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(box.reshape(-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#加载数据集标签名称</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_coco_names</span>(<span class="params">file_name</span>):</span></span><br><span class="line">    names = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">id</span>, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(f):</span><br><span class="line">            names[<span class="built_in">id</span>] = name</span><br><span class="line">    <span class="keyword">return</span> names</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv=<span class="literal">None</span></span>):</span></span><br><span class="line">    tf.reset_default_graph()</span><br><span class="line">    classes = load_coco_names(class_names)      <span class="comment">#这里的读取到的名字，都跟着一个换行符，可以使用.replace(&#x27;\n&#x27;, &#x27;&#x27;)删掉它</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义输入占位符</span></span><br><span class="line">    inputs = tf.placeholder(tf.float32, [<span class="literal">None</span>, size, size, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;detector&#x27;</span>):</span><br><span class="line">        detections = yolo_v3(inputs, <span class="built_in">len</span>(classes), data_format=<span class="string">&#x27;NHWC&#x27;</span>)<span class="comment">#定义网络结构</span></span><br><span class="line">        <span class="comment">#加载权重</span></span><br><span class="line">        load_ops = load_weights(tf.global_variables(scope=<span class="string">&#x27;detector&#x27;</span>), weights_file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    boxes = detections_boxes(detections)</span><br><span class="line"></span><br><span class="line">    sess = tf.Session()</span><br><span class="line">    sess.run(load_ops)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取视频文件</span></span><br><span class="line">    cap = cv2.VideoCapture(input_video)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#读帧</span></span><br><span class="line">    j=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> cap.isOpened():</span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line">        frame = Image.fromarray(cv2.cvtColor(frame,cv2.COLOR_BGR2RGB))      <span class="comment">#将cv2类型的图片转化为PIL类型的。参考：https://zhuanlan.zhihu.com/p/87441580</span></span><br><span class="line">        img_resized = frame.resize(size=(size, size))</span><br><span class="line"></span><br><span class="line">        detected_boxes = sess.run(boxes, feed_dict=&#123;inputs: [np.array(img_resized, dtype=np.float32)]&#125;)</span><br><span class="line">        <span class="comment">#对10647个预测框进行去重</span></span><br><span class="line">        filtered_boxes = non_max_suppression(detected_boxes, confidence_threshold=conf_threshold,iou_threshold=iou_threshold)</span><br><span class="line"></span><br><span class="line">        draw_boxes(j,filtered_boxes, frame, classes, (size, size))</span><br><span class="line">        </span><br><span class="line">        j=j+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>测试视频时，运行速度非常慢，我人工数了一下，几乎每输出一帧处理后的图片都需要8秒，这比v1慢的多很多（不到1秒就能1帧，v2最快，肉眼可见的快）。经过反复的修改后发现，时间浪费在了程序的冗余计算上，比如sess的闭合，要把sess.run(load_ops)  放在迭代程序之外，并且提前定义sess = tf.Session()    不能在迭代程序里一次次的使用with结构。最终的程序速度可以达到快于v1但慢于v2的状态，大概在1秒两帧的样子（当然，由于硬件差异，与作者给出的性能肯定是有差距，但和作者给出的性能对比是吻合的）。</p><p>&nbsp;</p><p>另外，在单张图片识别时，我用随机的不同的颜色描述不同种类的物体有助于区分，视觉体验较好；但在处理视频时，这种方式就会使结果显得很杂乱，因为连续的两张图中，同一个物体被标注了不同颜色就感觉很奇怪，所以就把随机颜色的功能删掉，改成固定颜色（青色）。</p><p>&nbsp;</p><p>还是老样子，取视频的第30帧做展示，输出视频（共208帧）已上传到蓝奏云网盘。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1534055/202007/1534055-20200727233022429-398110743.png"></p><p>&nbsp;</p><p>&nbsp;</p><div class="note success flat"><p>原视频 。见：<a href="https://wwa.lanzous.com/ivijLej0vmb">传送门</a></p><p>处理后的视频（因上传大小限制，分成了两段视频。）见：<a href="https://wwa.lanzous.com/i4Rvaey7gcd">传送门1</a>  <a href="https://wwa.lanzous.com/iH8gaey7hmj">传送门2</a></p><p>另外，检测到的bbox位置也特别多，无法截图展示，我就把信息全部写入到了txt文本中。注意：连续的三个为三个框，分别由一个换行符隔开；每一帧图片再由12个换行符隔开。见：<a href="https://cdn.jsdelivr.net/gh/han-suyu/cdn_others/final_v3.txt">传送门</a></p></div><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><blockquote><p><strong>参考：</strong><br><a href="https://pjreddie.com/darknet/yolo/">https://pjreddie.com/darknet/yolo/</a><br><a href="https://zhuanlan.zhihu.com/p/76802514">https://zhuanlan.zhihu.com/p/76802514</a><br><a href="https://www.jianshu.com/p/af8a9c83e530">https://www.jianshu.com/p/af8a9c83e530</a></p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://hansy.tech/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="目标检测" scheme="https://hansy.tech/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    
    <category term="目标检测" scheme="https://hansy.tech/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    <category term="YOLO" scheme="https://hansy.tech/tags/YOLO/"/>
    
  </entry>
  
</feed>

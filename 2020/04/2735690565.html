<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>一些“区别” - 愿风载尘</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>愿风载尘</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/photos/">
                <i class="iconfont icon-youtube-fill"></i>
                photos
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>








 

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                一些“区别”
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-04-05 22:43">
      2020年4月5日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      51
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h3 id="数组和结构体的区别"><a href="#数组和结构体的区别" class="headerlink" title="数组和结构体的区别"></a>数组和结构体的区别</h3><p>数组、结构体都是自建的数据结构，二者是相似的，但也有区别，其区别是：</p>
<ul>
<li>数组内部数据类型相同，结构体内部数据可以不同；</li>
</ul>
<ul>
<li>数组按下标访问，结构体因为数据类型不同，，只能使用<code>类名.变量名</code>来访问；</li>
</ul>
<h3 id="struct结构体和union共同体的异同点"><a href="#struct结构体和union共同体的异同点" class="headerlink" title="struct结构体和union共同体的异同点"></a>struct结构体和union共同体的异同点</h3><p><strong>相同点：</strong></p>
<ul>
<li>都是由多个不同的数据类型成员组成</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li><p>在struct中，每个成员都有自己的内存，它们同时存在，</p>
<p>在union中，所有成员不能同时占用各自的一块内存，因此不能同时存在，只能存在一个</p>
</li>
<li><p>struct的长度为所有成员长度之和，union的长度为最长成员的长度</p>
</li>
<li><p>对struct的不同成员之间的赋值互不影响，而union不同成员赋值会重写其他成员</p>
</li>
</ul>
<h3 id="C-中结构体和类的区别"><a href="#C-中结构体和类的区别" class="headerlink" title="C++中结构体和类的区别"></a>C++中结构体和类的区别</h3><ul>
<li><p>默认继承权限<br>class 的默认继承权限是 <code>private</code> ；struct的默认继承权限是 <code>public</code> </p>
</li>
<li><p>成员的默认访问权限<br>​class 定义的成员变量和函数的都是 <code>private</code> ；struct定义的变量和成员函数都是 <code>public</code> </p>
</li>
</ul>
<p>另：在C语言中 struct 只能定义数据成员，而不能定义成员函数。而在C++中，struct 类似于class，既可以定义成员变量，也可以定义成员函数.</p>
<h3 id="数组与链表的区别"><a href="#数组与链表的区别" class="headerlink" title="数组与链表的区别"></a>数组与链表的区别</h3><ul>
<li>数组静态分配内存；链表动态分配内存；</li>
<li>数组在内存中连续；链表可以不连续；</li>
<li>数组元素在栈区；链表元素在堆区；</li>
<li>数组利用下标定位，时间复杂度为O(1)；链表定位元素时间复杂度O(n)；</li>
<li>数组插入或删除元素的时间复杂度O(n)；链表的时间复杂度O(1)。</li>
</ul>
<h3 id="数组与指针的区别"><a href="#数组与指针的区别" class="headerlink" title="数组与指针的区别"></a>数组与指针的区别</h3><ol>
<li><p>数组：<strong>对应</strong>一块内存区域。其地址和大小在生命期里不会改变，只有数组的内容可以改变。</p>
<p>指针：<strong>指向</strong>一块内存区域。它指向的内存区域的大小可以随时改变，当指针指向字符串时，它的内容是不可以被修改的，否则在运行时会报错。</p>
</li>
<li><p>用运算符sizeof可以计算出数组的容量（字节数），而无法计算指针所指内存的容量，得到的结果永远4（即指针变量所占内存单元的字节数）</p>
</li>
<li><p>在进行参数传递时，数组会自动退化为同类型的指针。</p>
</li>
</ol>
<h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><ul>
<li>指针是变量，存放地址的变量，占用4Byte或者8Byte；引用是对象的别名，大小为被引用对象的大小。</li>
<li>指针可以为空，可以声明之后再初始化，初始化后可以再改变；引用必须在声明的时候初始化，而且初始化之后不可再改变</li>
<li>指针可以有多级，引用只能是一级</li>
<li>指针和引用的自增(++)运算意义不一样。指针自增表示地址加1，引用自增表示值加1</li>
</ul>
<h3 id="数组指针和指针数组"><a href="#数组指针和指针数组" class="headerlink" title="数组指针和指针数组"></a>数组指针和指针数组</h3><ul>
<li>int (*ptr)[5]，数组指针相当于二维数组，也就是指针的指针</li>
<li>int *ptr[5]，  指针数组是一个数组，数组存放的元素为指针</li>
</ul>
<h3 id="strlen和sizeof的区别"><a href="#strlen和sizeof的区别" class="headerlink" title="strlen和sizeof的区别"></a>strlen和sizeof的区别</h3><ul>
<li>strlen是函数，在运行时才能计算，返回字符串的长度，必须以‘\0’结尾</li>
<li>sizeof是运算符，在编译时就计算好了。</li>
</ul>
<h3 id="define与const的区别"><a href="#define与const的区别" class="headerlink" title="#define与const的区别"></a>#define与const的区别</h3><ul>
<li>define不会做类型检查（容易出错），const拥有类型，会执行相应的类型检查 </li>
<li>define仅仅是宏替换，不占用内存，而const会占用内存 </li>
<li>const内存效率更高，编译器可能将const变量保存在符号表中，而不会分配存储空间，这使得它成 为一个编译期间的常量，没有存储和读取的操作</li>
</ul>
<h3 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h3><ul>
<li>new按照数据类型进行分配，malloc 按照指定的大小分配</li>
<li>new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。</li>
<li>new 不仅分配一段内存，而且会调用构造函数，malloc 不会。</li>
<li>new分配的内存要用delete销毁，malloe 要用free来销毁；delete 会调用对象的析构函数，而free则不会。</li>
<li>new是一个操作符可以重载，malloc 是一个库函数。</li>
<li>malloc分配的内存不够的时候，可以用realloc扩容。 new没用这样操作。</li>
<li>new 如果分配失败了会抛出bad_malloc 的异常，而malloc失败了会返回NULL.</li>
<li>申请数组时： new[]一次分配所有内存， 多次调用构造函数，搭配使用delete[], delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n.</li>
</ul>
<h3 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h3><ul>
<li><h5 id="操作系统中的"><a href="#操作系统中的" class="headerlink" title="操作系统中的"></a>操作系统中的</h5></li>
</ul>
<p>逻辑结构：指一个文件在用户面前所呈现的形式.</p>
<p>​                    分类：①记录式文件(有结构式文件).<br>​                                ②流式文件（无结构式文件）</p>
<p>物理结构：指文件在文件存储器上的存储形式.<br>                    分类：①连续文件结构<br>　                            ②串联文件结构<br>​                                ③索引文件结构<br>​                                ④散列文件结构</p>
<ul>
<li><h5 id="数据结构中的"><a href="#数据结构中的" class="headerlink" title="数据结构中的"></a>数据结构中的</h5></li>
</ul>
<p>见另一文件</p>
<h3 id="逻辑文件和物理文件"><a href="#逻辑文件和物理文件" class="headerlink" title="逻辑文件和物理文件"></a>逻辑文件和物理文件</h3><ul>
<li>逻辑文件是数据的一种视图形式，不包含具体数据，但包含数据的索引</li>
<li>物理文件是文件在外存上的存储组织形式</li>
</ul>
<h3 id="机器语言、汇编语言和高级语言有何区别？"><a href="#机器语言、汇编语言和高级语言有何区别？" class="headerlink" title="机器语言、汇编语言和高级语言有何区别？"></a>机器语言、汇编语言和高级语言有何区别？</h3><ul>
<li>机器语言：站在计算机的角度，说计算机能听懂的语言。就是直接用二进制编程，直接操作硬件。</li>
<li>汇编语言：站在计算机的角度，用简写的英文标识符取代二进制去编写程序，本质上仍然是直接操作硬件。</li>
<li>高级语言：站在人的角度，说人话，即用人类的字符去编写程序，屏蔽了硬件操作。</li>
</ul>
<h3 id="C-对于对象的动态建立与静态建立"><a href="#C-对于对象的动态建立与静态建立" class="headerlink" title="C++对于对象的动态建立与静态建立"></a>C++对于对象的动态建立与静态建立</h3><ul>
<li><p>静态建立，例如 A a;</p>
<pre><code>由编译器为对象在栈空间中分配内存。这种方法是直接调用类的构造函数。</code></pre></li>
<li><p>动态建立，例如 A* a = new A();</p>
<pre><code>使用new运算符为对象在堆空间中分配内存。这种方法是间接调用类的构造函数。</code></pre><blockquote>
<p>第一步：执行operator new( )函数，在堆空间中搜索一块内存并进行分配</p>
<p>第二步：调用类的构造函数构造对象</p>
</blockquote>
</li>
</ul>
<p><strong>使用场景选择：</strong></p>
<p>​        静态对象由于是在栈中生成的，因而比动态的效率要高，而且不会造成内存泄露。静态较好<br>但标明动态对象的是一个指针，而标明静态对象的是一个值。当对象作为参数时，动态更好<br>另外，如果对象要在多个函数中使用，或者要在一个函数中建立，而在另一个函数中使用，动态更好</p>
<h3 id="Java变量的静态绑定与动态绑定"><a href="#Java变量的静态绑定与动态绑定" class="headerlink" title="Java变量的静态绑定与动态绑定"></a>Java变量的静态绑定与动态绑定</h3><ul>
<li>静态绑定发生在编译时期；动态绑定发生在运行时</li>
<li>静态绑定使用类信息完成；动态绑定使用对象信息完成</li>
<li>使用static或final修饰的，为静态绑定；使用虚函数的，为动态绑定</li>
<li>重载的方法为静态绑定；重写的方法为动态绑定</li>
</ul>
<h3 id="并行与并发的区别"><a href="#并行与并发的区别" class="headerlink" title="并行与并发的区别"></a>并行与并发的区别</h3><ul>
<li><p>并发是指宏观上在一段时间内能同时运行多个程序，在微观上，只是把这段时间再分成若干段，使多个进程快速交替的执行，使看起来像是在同时运行。</p>
</li>
<li><p>并行则指同一时刻能运行多个指令。无论从微观还是宏观，二者都是一起执行的。多处理机可以并行</p>
</li>
</ul>
<blockquote>
<p>从以上本质不难看出，“并发”执行，在多个进程而存在<code>资源冲突</code>时，并没有从根本提高执行效率。</p>
</blockquote>
<h3 id="内连接和外连接的区别"><a href="#内连接和外连接的区别" class="headerlink" title="内连接和外连接的区别"></a>内连接和外连接的区别</h3><p><code>join：将多个表连接起来查询。包括内连接与外连接</code></p>
<p>内连接是保证两个表中所有的行都要满足连接条件，而外连接则不然。</p>
<p>外连接在查询时，表有主从之分。如果符合连接条件则返回到结果集中；如果没有找到区配行，则在结果集中仍然保留主表的行，相对应的从表中的列被填上NULL值。</p>
<p>外连接分左连接（主表为左表）、右连接（…）、全连接三种。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<p>内连接：A表的所有行<strong>交</strong>上B表的所有行得出的结果集</p>
<p>全连接：A表的所有行<strong>并</strong>上B表的所有行得出的结果集</p>
</blockquote>
<h3 id="等值连接和自然连接的区别"><a href="#等值连接和自然连接的区别" class="headerlink" title="等值连接和自然连接的区别"></a>等值连接和自然连接的区别</h3><ul>
<li>等值连接使用’==‘符号，它是从两个关系的笛卡尔积中选出属性值相等的那些元组。</li>
<li>自然连接是一种特殊的等值连接。它要求去除重复列。</li>
</ul>
<h3 id="缓存（Cache）和缓冲（Buffer）的区别"><a href="#缓存（Cache）和缓冲（Buffer）的区别" class="headerlink" title="缓存（Cache）和缓冲（Buffer）的区别"></a>缓存（Cache）和缓冲（Buffer）的区别</h3><ul>
<li><p>cache 是为了提高cpu和内存之间的数据交换速度而引入的中间层，具体是利用局部性原理，把常用数据存储到可以快速获取的区域，以备重复利用。起到<strong>加快访问速度</strong>的作用。</p>
</li>
<li><p>buffer 的主要目的进行流量整形，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O，以<strong>减少I/O次数</strong>（比如从网上下电影，你不能下一点点数据就写一下硬盘，而是积攒一定量的数据以后一整块一起写，减少I/O次数）。</p>
</li>
</ul>
<h3 id="虚拟存储器和Cache存储器的异同"><a href="#虚拟存储器和Cache存储器的异同" class="headerlink" title="虚拟存储器和Cache存储器的异同"></a>虚拟存储器和Cache存储器的异同</h3><ul>
<li><p>相同点</p>
<ul>
<li>都是基于程序局部性原理，把程序中最近常用的部分驻留在高速存储器中，一旦这部分程序不常用，把它们送回到低速存储器中。</li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li>cache是用硬件实现的，是一个物理存储器；虚拟存储用操作系统与硬件结合的方式实现，是一个逻辑存储器。</li>
<li>在虚拟存储未命中的性能损失要大于cache系统未命中的损失。</li>
</ul>
</li>
</ul>
<h3 id="栈和队列的异同"><a href="#栈和队列的异同" class="headerlink" title="栈和队列的异同"></a>栈和队列的异同</h3><p>相同点：</p>
<ul>
<li>都是线性结构。</li>
<li>插入操作都是限定在表尾进行。</li>
<li>都可以通过顺序结构和链式结构实现。</li>
<li>插入与删除的时间复杂度都是O（1），在空间复杂度上两者也一样。</li>
</ul>
<p>不同点：</p>
<ul>
<li><p>一个是单端操作，一个是双端操作</p>
</li>
<li><p>栈能够实现多栈空间共享，而队列不能。</p>
</li>
<li><p>应用场景不同。栈：括号匹配、表达式的转换和求值、函数调用和递归实现、深度优先搜索遍历等；</p>
<p>​                           队列：打印机、广度优先搜索遍历等。</p>
</li>
</ul>
<h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><ul>
<li><p>按管理方式</p>
<ul>
<li>栈是系统编译器启动管理，不需要程序员手动管理</li>
<li>堆的释放由程序员手动管理，不及时回收容易产生内存泄露</li>
</ul>
</li>
<li><p>按分配方式</p>
<ul>
<li>栈有两种分配方式：静态分配和动态分配</li>
<li>堆是动态分配和回收内存的，没有静态分配的堆</li>
</ul>
</li>
<li><p>按分配大小</p>
<ul>
<li>栈是向低地址扩展的数据结构，是一块连续的内存区域</li>
<li>堆是向高地址扩展的数据结构，是不连续的内存区域</li>
</ul>
</li>
<li><p>按存储内容</p>
<ul>
<li>栈：存放函数的参数值，局部变变量的值等。</li>
<li>堆：new或者malloc出来的东西</li>
</ul>
</li>
</ul>
<h3 id="指令和程序的区别"><a href="#指令和程序的区别" class="headerlink" title="指令和程序的区别"></a>指令和程序的区别</h3><p>指令是指挥计算机执行各种操作的命令。程序是一组能由计算机识别和执行的指令序列。</p>
<blockquote>
<p>一条指令通常由两个部分组成：操作码+地址码。</p>
</blockquote>
<h3 id="数据库和数据仓库的区别"><a href="#数据库和数据仓库的区别" class="headerlink" title="数据库和数据仓库的区别"></a>数据库和数据仓库的区别</h3><blockquote>
<p>数据库主要用于<strong>事务处理</strong>；数据仓库主要用于<strong>数据分析</strong>。</p>
</blockquote>
<p>用途上的不同决定了这两种架构的特点不同。</p>
<p>数据库：</p>
<ul>
<li>相对复杂的表格结构，存储结构相对紧致，少冗余数据。</li>
<li>读和写都有优化。</li>
<li>相对简单的read/write query，单次作用于相对的少量数据。</li>
</ul>
<p>数据仓库：</p>
<ul>
<li>相对简单的(Denormalized)表格结构，存储结构相对松散，多冗余数据。</li>
<li>一般只是读优化。</li>
<li>相对复杂的read query，单次作用于相对大量的数据（历史数据）。</li>
</ul>
<h2 id="varchar和char的使用场景"><a href="#varchar和char的使用场景" class="headerlink" title="varchar和char的使用场景"></a>varchar和char的使用场景</h2><ul>
<li><p>varchar字符长度可变，但是不能超过设置的长度</p>
</li>
<li><p>char字符长度不可变，固定长度</p>
</li>
</ul>
<blockquote>
<p>一般设置登录名可以使用varchar，而<code>加密后的</code>密码一般设置为char，因为加密算法的结果是固定长度的。 </p>
</blockquote>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><ul>
<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作; </li>
<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。    </li>
</ul>
<h2 id="分区与分表的区别"><a href="#分区与分表的区别" class="headerlink" title="分区与分表的区别"></a>分区与分表的区别</h2><ul>
<li>分区：将一张表分解成多个更小的部分。从逻辑上看，还是一张表，但是底层却是由多个物理分区组成。</li>
<li>分表：指的是通过一定规则，将一张表分解成多张不同的表。</li>
</ul>
<blockquote>
<p>分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</p>
</blockquote>
<h3 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h3><ul>
<li><p>重写是子类根据自己的需要对父类的允许访问的方法的重新编写, 返回值和形参都不能改变。即<strong>外壳不变，核心重写</strong>！</p>
<blockquote>
<p>子类方法不能比父类的访问权限更严格。<br>子类方法不能抛出比父类方法更多的异常</p>
</blockquote>
</li>
<li><p>重载是在一个类里面，存在多个名字相同，而参数列表不同的函数。其返回类型可以相同也可以不同。</p>
</li>
</ul>
<blockquote>
<p><code>方法的重写和重载是多态性的不同表现。</code><br><code>重写是父类与子类之间多态性的一种表现；重载是一个类中多态性的一种表现。</code></p>
</blockquote>
<h3 id="c-中的map与set的区别"><a href="#c-中的map与set的区别" class="headerlink" title="c++中的map与set的区别"></a>c++中的map与set的区别</h3><p>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。</p>
<p>map和set区别在于：</p>
<ul>
<li>map中的元素是键值对，关键字起到索引的作用；Set每个元素只包含一个关键字。</li>
<li>map允许修改value，但不允许修改key。set的迭代器是const的，不允许修改元素的值。</li>
<li>map支持下标操作，set不支持下标操作。</li>
</ul>
<blockquote>
<p>Collection<br>├-<strong>List</strong>（有序有重）<br>│ ├-LinkedList<br>│ ├-ArrayList<br>│ └-Vector<br>│　 └-Stack<br>└<strong>Set</strong>（无序无重）<br>├-HashSet<br>└-TreeSet<br><strong>Map</strong>（无序。键值对映射，值可以重复，但键不可以重复）<br>├-Hashtable<br>├-HashMap<br>└-TreeMap</p>
<blockquote>
<p>Set的底层实现是Map，所以是无序的；又因为在Map中key的值不能重复，所以set中的元素不能重复。</p>
</blockquote>
</blockquote>
<h3 id="静态链接与动态链接的区别"><a href="#静态链接与动态链接的区别" class="headerlink" title="静态链接与动态链接的区别"></a>静态链接与动态链接的区别</h3><ul>
<li><p>在链接阶段，将汇编生成的.o目标文件与引用到的库一起链接打包到可执行文件中。</p>
<p>程序在运行时与函数库再无瓜葛，<strong>易于移植</strong>。</p>
</li>
<li><p>动态库把对库函数的链接推迟到程序运行时。可以实现进程之间的<strong>资源共享</strong>。</p>
<p>因此动态库也称为共享库</p>
</li>
</ul>
<h3 id="内存溢出与内存泄漏的区别"><a href="#内存溢出与内存泄漏的区别" class="headerlink" title="内存溢出与内存泄漏的区别"></a>内存溢出与内存泄漏的区别</h3><ul>
<li><p>内存溢出：指程序申请内存时，没有足够的内存供申请者使用。</p>
</li>
<li><p>内存泄漏：指未能及时释放掉已经申请的但不再使用的内存。</p>
<blockquote>
<p>c++使用varglind、mtrace来处理内存泄漏</p>
</blockquote>
</li>
</ul>
<h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><ul>
<li>URI(Identifier，统一资源标识符)，用来唯一的标识一个Web上的资源。</li>
</ul>
<ul>
<li><p>URL(Locator，统一资源定位符)，用来标识一个资源，而且还指明了如何寻找这个资源。</p>
<p>URL一般由三部组成：   例如：<code>https://host:port/path?xxx=aaa&amp;ooo=bbb</code></p>
<ol>
<li>协议(或称为服务方式)</li>
<li>存有该资源的主机IP地址(有时也包括端口号)</li>
<li>主机资源的访问路径。如目录和文件名等</li>
</ol>
</li>
</ul>
<p>​       </p>
<h3 id="Cookies和Session区别"><a href="#Cookies和Session区别" class="headerlink" title="Cookies和Session区别"></a>Cookies和Session区别</h3><ul>
<li>cookie数据存放在浏览器上；session数据存放在服务器上</li>
<li>cookie是不安全的，别人可以分析存放在本地的cookie进行cookie欺骗</li>
<li>当访问量大时，session会占用服务器空间，影响性能</li>
</ul>
<h3 id="post与get的异同"><a href="#post与get的异同" class="headerlink" title="post与get的异同"></a>post与get的异同</h3><ul>
<li><p>相同点</p>
<p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP。GET和POST能做的事情是一样的。</p>
<p>你要给GET加上request body，给POST带上url参数，技术上是完全行的通的</p>
</li>
<li><p>不同点</p>
<ul>
<li>get用来从服务器上获得资源；post是向服务器提交数据</li>
<li>get将数据放在url上，使用”?”、”&amp;”连接；post将数据放在http协议的请求头或消息体中</li>
<li>get传输的数据要受到url长度限制(1024字节)；post可以传输大量数据</li>
<li>使用get时参数会显示在地址栏中，不安全</li>
</ul>
</li>
</ul>
<h3 id="CS和BS的区别"><a href="#CS和BS的区别" class="headerlink" title="CS和BS的区别"></a>CS和BS的区别</h3><p><strong>CS:</strong> 即客户端、服务器编程。客户端、服务端之间需要使用Socket，约定数据格式、协议（往往使用的协议是TCP或者UDP），指定地址和端口，就可以通信了。     </p>
<p><strong>BS:</strong> 即浏览器、服务器开发。Browser浏览器是一种特殊的客户端，支持HTTP(s)等协议，能够通过URL向服务端发起请求，等待服务端返回HTML等数据，并在浏览器内可视化展示的程序。          </p>
<blockquote>
<p>本质上来说，BS是一种特殊的CS。HTTP协议底层基于TCP协议实现。 </p>
</blockquote>
<h5 id="BS开发常用的技术"><a href="#BS开发常用的技术" class="headerlink" title="BS开发常用的技术"></a>BS开发常用的技术</h5><p>客户端开发，或称前端开发。<code>HTML</code>、<code>CSS</code>、<code>JavaScript</code>等…<br>服务端开发，有<code>Java</code>、<code>.net</code>、<code>Python中的Django框架</code>等…        </p>
<h3 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h3><ul>
<li><p>路由器：作用在网络层。根据包头中的目标IP在路由表中寻找，由IP和子网掩码得出网络号，然后在路由表中的“目标地址项中的IP按位从左向右与刚刚算出的网络号对比，如果相同，就将包从此条记录的对应的“接口”选项发出去。</p>
</li>
<li><p>交换机：作用在数据链路层。根据包头中的MAC地址，在交换机内部的MAC地址表，找到该MAC地址对应的端口，然后将包从该端口（一个端口对应一个MAC地址）发送出去。</p>
</li>
</ul>
<h3 id="key和index的区别"><a href="#key和index的区别" class="headerlink" title="key和index的区别"></a>key和index的区别</h3><ul>
<li><p>KEY是逻辑级别的东西，描述表和数据库设计</p>
</li>
<li><p>INDEX是物理级别的东西，有助于缩短表操作的访问时间。</p>
</li>
</ul>
<h3 id="重定向和转发的区别"><a href="#重定向和转发的区别" class="headerlink" title="重定向和转发的区别"></a>重定向和转发的区别</h3><ul>
<li><p>转发是在服务器端的跳转，浏览器并不知情，地址栏不会改变。</p>
<p>具体：浏览器向服务器发送一个请求，服务器直接将请求相关的参数的信息原封不动的传递到该服务器的其他jsp或servlet去处理</p>
</li>
<li><p>而重定向是在浏览器的跳转，浏览器知情，地址栏变成重定向后的地址。</p>
<p>具体：服务器会返回给浏览器一个响应报头和新的URL地址，原来的参数或者其他的一些信息，如果服务器端没有特别处理就不存在了，浏览器会访问新的URL所指向的servlet 或 jsp。</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%9D%82/">杂</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/04/715736860.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">c、c++、Java编程语言的对比</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/04/420662040.html">
                        <span class="hidden-mobile">程序执行过程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "0GczNmun2zmN2vdrogxJXWU3-gzGzoHsz",
          app_key: "NlTLpnO69Qf4A1UR4Dk7S65w",
          placeholder: "说点什么",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: true,
          recordIP: false,
          serverURLs: "",
        });
      });
    }
    createObserver(loadValine, 'vcomments');
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer>
  (function () {
    // 查询存储的记录
    function getRecord(Counter, target) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({target})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {target, time: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    }

    // 发起自增请求
    function increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    }

    // 构建自增请求体
    function buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "time": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    }

    // 校验是否为有效的 UV
    function validUV() {
      var key = 'LeanCloud_UV_Flag';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    }

    function addCount(Counter) {
      var enableIncr = 'true' === 'true' && window.location.hostname !== 'localhost';
      var getterArr = [];
      var incrArr = [];

      // 请求 PV 并自增
      var pvCtn = document.querySelector('#leancloud-site-pv-container');
      if (pvCtn || enableIncr) {
        var pvGetter = getRecord(Counter, 'site-pv').then((record) => {
          incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-pv');
          if (ele) {
            ele.innerText = record.time + 1;
            if (pvCtn) {
              pvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#leancloud-site-uv-container');
      if (uvCtn || enableIncr) {
        var uvGetter = getRecord(Counter, 'site-uv').then((record) => {
          var vuv = validUV();
          vuv && incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-uv');
          if (ele) {
            ele.innerText = record.time + (vuv ? 1 : 0);
            if (uvCtn) {
              uvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(uvGetter);
      }

      // 如果是文章，请求文章的浏览数，并自增
      if ('true' === 'true') {
        var viewCtn = document.querySelector('#leancloud-post-views-container');
        if (viewCtn || enableIncr) {
          var target = decodeURI('/2020/04/2735690565.html');
          var viewGetter = getRecord(Counter, target).then((record) => {
            incrArr.push(buildIncrement(record.objectId))
            if (viewCtn) {
              var ele = document.querySelector('#leancloud-post-views');
              if (ele) {
                ele.innerText = (record.time || 0) + 1;
                viewCtn.style.display = 'inline';
              }
            }
          });
          getterArr.push(viewGetter);
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && increment(Counter, incrArr);
        })
      }
    }

    var app_id = '0GczNmun2zmN2vdrogxJXWU3-gzGzoHsz'
    var app_key = 'NlTLpnO69Qf4A1UR4Dk7S65w'
    var server_url = 'https://0gcznmun.lc-cn-n1-shared.com'

    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': app_id,
            'X-LC-Key': app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };

      addCount(Counter);
    }

    var api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${ app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(resp => resp.json())
        .then(({api_server}) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>






  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>

















  

  

  

  

  

  





</body>
</html>
